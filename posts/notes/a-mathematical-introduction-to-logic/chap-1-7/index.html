<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ch1. Sentential Logic :: 1.7 Compactness and Effectiveness</title>
    
    <link rel="stylesheet" href="/res/libs/fontawesome/css/all.min.css"></link>
    <link rel="stylesheet" href="/res/libs/chota/css/chota.min.css"></link>

    <link rel="stylesheet" href="/res/style/site-gruvbox-soft.min.a69db7f7950fa2a698891fccb16b7a9e6351774c9914ea9f97cff7d7dfc13f90.css"></link>
    <script type="text/javascript" src="/res/script/site.min.a65b2836eec5187e9e88be5dae41f6f388a8c97455a87c31ff2e118d8b3bcd81.js"></script>

    <link id="markdown-body-style" rel="stylesheet" href="/res/style/markdown-body-gruvbox-soft.min.9e60b1b898fdbd462bd36ce7d16c6ff301f66ec653f0b24c613a95f9709987a4.css"></link>
    <script type="text/javascript" src="/res/script/markdown-body.min.35e011193a484812039d96b17af075e907d451e72d29301c94e49f045c43c19d.js"></script>

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">


  </head>

  <body>
    
    <div id="header">
      
      <nav id="navbar" class="row">
        <div class="is-left col-12 col-3-md row">
          <a id="navbar-brand" class="brand" href="/">Coder Papa</a>
          <label id="navbar-toggle-menu" for="navbar-toggle-menu-state" class="hide-md hide-lg">
            <span></span>
            <span></span>
            <span></span>
          </label>
        </div>
        <input id="navbar-toggle-menu-state" type="checkbox" style="display:none"></input>
        <div id="navbar-menu" class="is-right col-12 col-9-md row hide-xs-noimportant hide-sm-noimportant">
          
          <a href="/posts">Posts</a>
          
          
          <a href="/categories">Categories</a>
          
          <a href="/tags">Tags</a>
          
          
          <a href="https://github.com/huangjunwen"><i class='fab fa-github'></i></a>
          
          <a href="javascript:void(0)" id="navbar-toggle-mode" onclick="return toggleColorMode()"></a>
        </div>
      </nav>
    </div>

    
    <div id="main" class="row">
      <div id="main-left" class="hide-xs hide-sm col-2-md col-3-lg">
        
      </div>
      <div id="main-center" class="col-12 col-8-md col-6-lg mdb">
        <div id="main-title" class="text-center">
          
  <h5 class="no-toc"><span class="breadcrumbnav"><span><a href="/posts/">POSTS</a></span><i class="fa fa-fw fa-angle-double-right"></i><span><a href="/posts/notes/">NOTES</a></span><i class="fa fa-fw fa-angle-double-right"></i><span><a href="/posts/notes/a-mathematical-introduction-to-logic/">A MATHEMATICAL INTRODUCTION TO LOGIC 笔记</a></span></span></h5>
  <h1>Ch1. Sentential Logic :: 1.7 Compactness and Effectiveness</h1>
  <small>
    <time class="" datetime="2023-05-13T00:39:20Z">Sat, 2023/05/13</time>
  </small>
  <p>
    
    
  </p>
  
        </div>
        <div id="main-body">
          
  <article id="content-body">
    <h2 id="compactness">Compactness</h2>
<dl>
<dt>satisfiable</dt>
<dd>
如果有一赋值（truth assignment）满足一个合式公式集合 \(\Sigma\)
中的每一个，则称 \(\Sigma\) 是<strong>可满足的（satisfiable）</strong>
</dd>
</dl>
<p>例如 \(\Sigma = \{A_1, A_2 \rightarrow A_1 \}\)，由于赋值 \(v =
\langle A_1 = T, A_2 = T \rangle\) 可满足 \(\Sigma\) 中的两个式子
（即在此赋值下两个式子都得值 \(T\)），故 \(\Sigma\) 可满足</p>
<p>又例如 \(\Sigma = \{A_1, \neg A_1 \}\)，没有一个赋值可以同时满足
\(\Sigma\) 中的两个式子，故 \(\Sigma\) 不可满足</p>
<h3 id="compactness-theorem">Compactness Theorem</h3>
<p>以下是这一节的主要定理</p>
<blockquote>
<p>一个合式公式集合是可满足的，当且仅当其每一个<strong>有限</strong>子集都是可满足的</p>
</blockquote>
<p>首先这里临时定义：如果一个合式公式集合 \(\Sigma\)
的每一个<strong>有限</strong>子集都可满足的话，称 \(\Sigma\)
为<strong>有限可满足（finitely satisfiable）</strong>； 所以 Compactness
Theorem 表述的就是 <strong>有限可满足</strong> 跟
<strong>可满足</strong> 其实是等价的</p>
<p>注意：</p>
<ol type="1">
<li><p>如果 \(\Sigma\) 是 <strong>可满足</strong> 的话，则其自动就是
<strong>有限可满足</strong> 的
（因为如果有一个赋值能满足集合中的每一个式子，自然也能满足其任意子集中的每一个式子）</p></li>
<li><p>反过来，如果 \(\Sigma\) 是 <strong>有限可满足</strong>
的话，分两种情况</p>
<ol type="1">
<li><p>如果 \(\Sigma\) 本身就是 <strong>有限集合</strong>
的话，则它也就是 <strong>可满足</strong>
的（因为它就是本身的有限子集）</p></li>
<li><p>剩下需要证明的就是 \(\Sigma\) 是 <strong>无限集合</strong> 且是
<strong>有限可满足</strong>，则其是 <strong>可满足的</strong>
的</p></li>
</ol></li>
</ol>
<div class="proof">
<div class="proof-label">
Proof
</div>
<div class="proof-content">
<p>证明分两部分</p>
<hr />
<p>证明的第一部分扩展 \(\Sigma\) 到最大：</p>
<p>首先，令 \(\alpha_1, \alpha_2, ...\) 为全体合式公式<a href="#fn1"
class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>，然后递归地定义：</p>
<p>\[
\begin{split}
\Delta_0 &amp; = \Sigma \\
\Delta_{n+1} &amp; =
  \begin{cases}
  \Delta_n ; \alpha_{n+1} ~~~~~~~~~ \text{if this is finitely
satisfiable} \\
  \Delta_n ; \neg \alpha_{n+1} ~~~~~~ \text{otherwise} \\
  \end{cases}
\end{split}
\]</p>
<p><em>（注：\(\Delta ; \alpha\) 是 \(\Delta \cup \{ \alpha \}\)
的简写）</em></p>
<p>即假如 \(\Delta_n ; \alpha_{n+1}\) 仍然是 <strong>有限可满足</strong>
那么令 \(\Delta_{n+1}\) 等于该集合</p>
<p>否则意味着 <strong>至少</strong> 有一个 <strong>有限子集</strong>
\(\Gamma_n \subset \Delta_n\) 使得 \(\Gamma_n ; \alpha_{n+1}\) 是
<strong>无法满足</strong> 的，所以：</p>
<ol type="1">
<li>对于任意 <strong>满足</strong> \(\Gamma_n\) 的赋值 \(v\)
<strong>都无法满足</strong> \(\alpha_{n+1}\)</li>
<li>对于任意 <strong>满足</strong> \(\Gamma_n\) 的赋值 \(v\)
<strong>都满足</strong> \(\neg \alpha_{n+1}\)</li>
<li>考虑 <strong>任意</strong> 有限子集 \(\Delta'_n \subset
\Delta_n\)，首先存在赋值 \(v\) 满足 \(\Delta'_n \cup
\Gamma_n\)（有限可满足性）， 即 \(v\) 同时满足 \(\Delta'_n\) 和
\(\Gamma_n\)，因此根据 2 \(v\) 也满足 \(\neg \alpha_{n+1}\)，所以 \(v\)
满足 \(\Delta'_n ; \neg \alpha_{n+1}\)</li>
<li>所以 \(\Delta_n ; \neg \alpha_{n+1}\) 也是有限可满足的<a href="#fn2"
class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a></li>
</ol>
<p>通过这种方式从初始的有限可满足集合 \(\Sigma\)
出发，每次添加一个合式公式并保证新集合依然有限可满足；令 \(\Delta =
\cup_n \Delta_n\)，可知</p>
<ol type="1">
<li>\(\Sigma \subseteq \Delta\)</li>
<li>对任意合式公式 \(\alpha\)，要么 \(\alpha \in \Delta\) 要么 \(\neg
\alpha \in \Delta\) <a href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a></li>
<li>\(\Delta\) 有限可满足，因为其任意有限子集必定可由某个 \(\Delta_n\)
所包含，而所有 \(\Delta_n\) 都是有限可满足的</li>
</ol>
<hr />
<p>证明的第二部分给出一个对所有命题符号的赋值 \(v\)：</p>
<p>\[
v(A) =
  \begin{cases}
  T ~~~~ A \in \Delta \\
  F ~~~~ A \notin \Delta \\
  \end{cases}
\]</p>
<p>下面证明<strong>任意合式公式被该赋值满足当且仅当该公式属于
\(\Delta\)</strong>（Exercise 2）</p>
<p>令 \(\Lambda_u(\psi) =  \begin{cases}  \psi ~~~~ u = T \\  \neg \psi
~~~~ u = F \\  \end{cases}\)，易知<strong>任意赋值 \(v\) 满足
\(\Lambda_u(\psi)\) 当且仅当 \(u = \bar{v}(\psi)\)</strong>
<sup>(+)</sup></p>
<p>再令 \(S = \{ \psi ~|~ \Lambda_{\bar{v}(\psi)}(\psi) \in \Delta
\}\)，即在 \(v\) 赋值下，使得 \(\Lambda_{\bar{v}(\psi)}(\psi)\) 属于
\(\Delta\) 的那些式子 \(\psi\)</p>
<p>下面证明 \(S\) 即全体合式公式：</p>
<p>首先所有命题符号 \(A\) 均属于 \(S\)，因为：</p>
<ul>
<li>若 \(\bar{v}(A) = v(A) = T\)，由定义知 \(A \in \Delta\)，故
\(\Lambda_{\bar{v}(A)}(A) = A \in \Delta\)</li>
<li>若 \(\bar{v}(A) = v(A) = F\)，由定义知 \(A \notin \Delta\)，由 2 得
\(\neg A \in \Delta\)，故 \(\Lambda_{\bar{v}(A)}(A) = \neg A \in
\Delta\)</li>
</ul>
<p>第二，\(S\) 闭合于 \(\varepsilon_{\neg}\)，假设 \(\psi \in S\)，即
\(\Lambda_{\bar{v}(\psi)}(\psi) \in \Delta\)</p>
<ul>
<li>由 2 得要么 \(\Lambda_{\bar{v}(\neg \psi)}(\neg \psi) \in \Delta\)
<sup>(1)</sup> 要么 \(\Lambda_{\neg \bar{v}(\neg \psi)}(\neg \psi) =
\Lambda_{\bar{v}(\psi)}(\neg \psi) \in \Delta\) <sup>(2)</sup></li>
<li>但如果是 <sup>(2)</sup> 成立的话，跟 \(\Lambda_{\bar{v}(\psi)}(\psi)
\in \Delta\) 矛盾，故只能 <sup>(1)</sup> 成立，所以 \(\neg \psi \in
S\)</li>
</ul>
<p>第三，\(S\) 闭合于 \(\varepsilon_{\square}\) <a href="#fn4"
class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>，假设 \(\psi_1, \psi_2 \in S\)， 即
\(\Lambda_{\bar{v}(\psi_1)}(\psi_1), \Lambda_{\bar{v}(\psi_2)}(\psi_2)
\in \Delta\)</p>
<ul>
<li>由 2 得要么 \(\Lambda_{\bar{v}(\psi_1 \square \psi_2)}(\psi_1
\square \psi_2) \in \Delta\) <sup>(1)</sup>， 要么 \(\Lambda_{\neg
\bar{v}(\psi_1 \square \psi_2)}(\psi_1 \square \psi_2) \in \Delta\)
<sup>(2)</sup></li>
<li>但如果是 <sup>(2)</sup> 成立的话，集合 \(\{
\Lambda_{\bar{v}(\psi_1)}(\psi_1), \Lambda_{\bar{v}(\psi_2)}(\psi_2),
\Lambda_{\neg \bar{v}(\psi_1 \square \psi_2)}(\psi_1 \square \psi_2)
\}\) 就是 \(\Delta\) 的有限子集，故应该存在一个赋值 \(v'\)
同时满足这三个式子，由 <sup>(+)</sup> 可得
<ul>
<li>\(\bar{v}(\psi_1) = \bar{v'}(\psi_1)\)</li>
<li>\(\bar{v}(\psi_2) = \bar{v'}(\psi_2)\)</li>
<li>\(\neg \bar{v}(\psi_1 \square \psi_2) = \bar{v'}(\psi_1 \square
\psi_2)\)</li>
<li>但这是矛盾的<a href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>，因为 \[
\begin{split}
\bar{v}(\psi_1 \square \psi_2) &amp; = \bar{\square}(\bar{v}(\psi_1),
\bar{v}(\psi_2)) \\
                               &amp; = \bar{\square}(\bar{v'}(\psi_1),
\bar{v'}(\psi_2)) \\
                               &amp; = \bar{v'}(\psi_1 \square \psi_2) =
\neg \bar{v}(\psi_1 \square \psi_2) \\
\end{split}
\] 故只能 <sup>(1)</sup> 成立，所以 \(\psi_1 \square \psi_2 \in S\)</li>
</ul></li>
</ul>
<p>故 \(S\) 是 inductive 集合，由 <a
href="../chap-1-4/#induction-principle">Induction Principle</a> 得出
\(S\) 是全体合式公式集合</p>
<p><strong>所以对任意合式公式 \(\psi\)，有
\(\Lambda_{\bar{v}(\psi)}(\psi) \in \Delta\)</strong>；即如果
\(\bar{v}(\psi) = T\) 则 \(\psi \in \Delta\)， 如果 \(\bar{v}(\psi) =
F\) 则 \(\neg \psi \in \Delta\) 由 2 得 \(\psi \notin
\Delta\)；<strong>所以就是 \(v\) 满足 \(\psi\) 当且仅当 \(\psi \in
\Delta\)</strong></p>
<p>由于 \(\Sigma \subseteq \Delta\)，故 \(v\) 满足 \(\Sigma\)
中的任意式子</p>
</div>
</div>
<h3 id="corollary-17a">Corollary 17A</h3>
<blockquote>
<p>如果 \(\Sigma \vDash \psi\)，则存在有限子集 \(\Sigma_0 \subseteq
\Sigma\) 使得 \(\Sigma_0 \vDash \psi\)</p>
</blockquote>
<div class="proof">
<div class="proof-label">
Proof
</div>
<div class="proof-content">
<p>下面要用到这一性质：<strong>\(\Sigma \nvDash \psi\) 当且仅当
\(\Sigma; \neg \psi\) 可满足</strong> <a href="#fn6"
class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<p>如果不存在这样的有限子集，则对任意有限子集 \(\Sigma' \subseteq
\Sigma\) 都有 \(\Sigma' \nvDash \psi\)</p>
<p>故对任意有限子集 \(\Sigma' \subseteq \Sigma\) 都有 \(\Sigma'; \neg
\psi\) 可满足</p>
<p>由 Compactness Theorem 可知 \(\Sigma; \neg \psi\) 可满足</p>
<p>于是 \(\Sigma \nvDash \psi\)
跟假设矛盾，故这样的有限子集必定是存在的</p>
</div>
</div>
<p><strong>实际上，该 Corollary 和 Compactness Theorem
是等价的</strong>，下面由该 Corollary 可轻易证明 Compactness
Theorem（Exercise 3）</p>
<div class="proof">
<div class="proof-label">
Proof
</div>
<div class="proof-content">
<p>首先假设 \(\Sigma\) 是有限可满足却不可满足的</p>
<p>设 \(\Sigma = \Sigma'; \psi\)，即任取一个 \(\Sigma\) 中的元素
\(\psi\)，剩下的元素组成 \(\Sigma'\)； 该集合不可满足当且仅当 \(\Sigma'
\vDash \neg \psi\)</p>
<p>由 Corollary 17A 得出存在有限集合 \(\Sigma_0' \subseteq
\Sigma'\)，使得 \(\Sigma_0' \vDash \neg \psi\)， 故 \(\Sigma_0'; \psi\)
不可满足</p>
<p>但注意到 \(\Sigma_0'; \psi\) 实际上是 \(\Sigma\)
的有限子集，跟有限可满足性矛盾，故 \(\Sigma\) 必定是可满足的</p>
</div>
</div>
<h2 id="effectiveness-and-computability">Effectiveness and
Computability</h2>
<p>当我们说：对于一个合式公式集合 \(\Sigma\) 以及一个公式 \(\psi\)
是否有一个<strong>有效的过程</strong>（effective procedure）判断
\(\Sigma \vDash \psi\)</p>
<p>那么何为有效的过程呢？这里指的是满足如下的过程：它应该包含精确的指令序列（e.g. 即程序）来描述如何执行该过程，
<strong>该程序只能有有限长度</strong>，否则任何机器和人都无法执行；再有，对于像上述那种判定过程，<strong>该程序应该在有限步之后给出结果</strong>；
最后，该程序不能要求任何需要洞察/创意等的介入，必须可以被机械地执行</p>
<p>总而言之，就是一个<strong>时间空间上均有限的机械步骤</strong>，但这里我们并不限制<strong>有限</strong>的大小</p>
<p>另外，上述的定义其实是 informal 的：</p>
<blockquote>
<p>Of course the foregoing description can hardly be considered a
precise definition of the word “effective”. And, in fact, that word will
be used only in an <strong>informal intuitive way</strong> throughout
this book. (In Chapter 3 we will meet a precise counterpart,
“recursive.”) But as long as we restrict ourselves to <strong>positive
assertions that there does exist an effective procedure of a certain
sort, the informal approach suffices</strong>. We simply display the
procedure, show that it works, and people will agree that it is
effective. (But this relies on the empirical fact that procedures which
appear effective to one mathematician also appear so to others.) If we
wanted a negative result, <strong>that there did not exist an effective
procedure of a certain sort, then this informal viewpoint would be
inadequate</strong>. (In Chapter 3 we do want to obtain just such
negative results.) Because the notion of effectiveness is informal,
definitions and theorems involving it will be <strong>marked with a
star</strong></p>
</blockquote>
<h3 id="可判定性">⚹ 可判定性</h3>
<dl>
<dt>⚹ Decidable</dt>
<dd>
一个表达式集合 \(\Sigma\)
是<strong>可判定（decidable）</strong>的意思是：存在一个有效过程，对于给定的任意表达式
\(\alpha\)， 可判定<strong>是否</strong> \(\alpha \in \Sigma\)（即当
\(\alpha \in \Sigma\) 返回 yes, 当 \(\alpha \notin \Sigma\) 返回 no）
</dd>
</dl>
<p>例如：</p>
<blockquote>
<p><strong>所有的有限集合都可判定</strong></p>
</blockquote>
<p>因为可以将所有有限个成员全部列出来，然后程序可以逐一检查对比输入</p>
<blockquote>
<p><strong>不是所有无限集合都可判定</strong></p>
</blockquote>
<p>假如都可判定，则每一个集合都至少有一个有效过程可对其进行判定（注意判定一个集合
\(\Sigma\)
的有效过程只能判定该集合而不能判定其他不同的集合），所以这些表达式集合的数量必须不多于有效过程的数量；
但表达式集合的数量是不可数的（\(2^{\aleph_0}\)，因为是全体表达式的 power
set），而全体有效过程的数量却是可数的
（\(\aleph_0\)，因为有效过程由其<strong>有限长度的指令</strong>定义，故可以与某个自然数对应）</p>
<h3 id="theorem-17b">⚹ Theorem 17B</h3>
<blockquote>
<p>存在有效过程判定任意一个表达式是否是合式公式</p>
</blockquote>
<p>1.3 节里的那个 parser algorithm
就是这么个算法；另一种意思就是：<strong>所有合式公式组成的集合是可判定的</strong></p>
<h3 id="theorem-17c">⚹ Theorem 17C</h3>
<blockquote>
<p>对于一个<strong>有限</strong>合式公式集合 \(\Sigma;
\psi\)，存在有效过程判定是否 \(\Sigma \vDash \psi\)</p>
</blockquote>
<p>1.2 节里的真值表方法满足要求</p>
<h3 id="corollary-17d">⚹ Corollary 17D</h3>
<blockquote>
<p>对于一个<strong>有限</strong>式子集合
\(\Sigma\)，其<strong>重言式推论集合（set of tautological
consequences）</strong>是可判定的； 特别地，<strong>重言式集合（set of
tautologies）</strong>是可判定的（因为重言式集合就是空集的重言式推论集）</p>
</blockquote>
<p>直接用 Theorem 17C
中的有效过程（真值表方法），输入任意式子即可判定是否是 \(\Sigma\) 的
tautological consequence 了</p>
<h3 id="半可判定性">⚹ 半可判定性</h3>
<dl>
<dt>⚹ Semidecidable</dt>
<dd>
一个表达式集合 \(\Sigma\)
是<strong>半可判定（semidecidable）</strong>的意思是：存在一个有效过程，对于给定的任意表达式
\(\alpha\)， 当且仅当 \(\alpha \in \Sigma\) 的时候可获得判定（即如果
\(\alpha \notin \Sigma\)，则该过程不一定能给出答案）
</dd>
<dt>⚹ Effectively Enumerable</dt>
<dd>
一个表达式集合 \(\Sigma\) 是<strong>有效可枚举（effectively
enumerable）</strong>的意思是：存在一个有效过程， 能按某种顺序将
\(\Sigma\) 中的所有成员枚举出来（注意，如果 \(\Sigma\)
是无限集合，则这个枚举过程永远不会结束，
但对于其中任意一个成员，都在某个有限时间内能被枚举出来）
</dd>
</dl>
<h3 id="theorem-17e">⚹ Theorem 17E</h3>
<blockquote>
<p>一个表达式集合是<strong>有效可枚举的</strong>当且仅当它是<strong>半可判定的</strong></p>
</blockquote>
<div class="proof">
<div class="proof-label">
Proof
</div>
<div class="proof-content">
<p>如果集合 \(\Sigma\)
是有效可枚举的，则有一个有效过程可以不断地输出该集合中的成员，对于任意一个表达式
\(\psi\)， 如果 \(\psi \in
\Sigma\)，则经过一段（可能相当长的）有限的时间后必定会出现，此时可输出
yes；如果 \(\psi \notin \Sigma\) 则永远不会有输出；故是半可判定的</p>
<p>反过来，如果该集合是半可判定的，而我们希望能枚举它的全部成员：首先是可以枚举所有的表达式
\(\psi_1, \psi_2, \psi_3, ...\) 的，
<strong>但不可以直接逐一地都执行那个半可判定的有效过程，因为如果某个
\(\psi_i \notin \Sigma\)，该过程有可能会一直不停机</strong>，
故需要调整一下方法，例如：</p>
<ol type="1">
<li>对 \(\psi_1\) 执行该过程 1 分钟进行判定</li>
<li>对 \(\psi_1\) 执行该过程 2 分钟进行判定，对 \(\psi_2\) 执行该过程 2
分钟进行判定</li>
<li>对 \(\psi_1\) 执行该过程 3 分钟进行判定，对 \(\psi_2\) 执行该过程 3
分钟进行判定，对 \(\psi_3\) 执行该过程 3 分钟进行判定</li>
<li>…</li>
</ol>
<p>对任意一个成员来说，总会有一个足够大的步数 \(n\)
包含它并且有足够长的时间足以判定它的 membership 并输出出来</p>
</div>
</div>
<blockquote>
<p>显然可判定集合也是半可判定集合，故也是有效可枚举的</p>
</blockquote>
<h3 id="theorem-17f">⚹ Theorem 17F</h3>
<blockquote>
<p>一个表达式集合是可判定的，当且仅当该集合以及其补集（complement，相对于全体表达式集合而言）都是有效可枚举的</p>
</blockquote>
<p>这个 Theorem 又称为 “Kleene’s theorem” (Exercise 8)</p>
<div class="proof">
<div class="proof-label">
Proof
</div>
<div class="proof-content">
<p>如果 \(\Sigma\) 可判定，则对所有表达式 \(\psi_1, \psi_2, \psi_3,
...\) 逐一执行其判定过程，过滤只返回 yes
的就可以获得该集合有效可枚举的过程；过滤只返回 no
的就可以获得该集合补集的有效可枚举的过程</p>
<p>反过来，如果存在 \(\Sigma\) 的有效可枚举过程 \(P\) 以及 \(\Sigma\)
补集的有效可枚举过程 \(P'\)，对任意输入 \(\alpha\)：</p>
<ol type="1">
<li>执行 \(P\) 1 分钟看 \(\alpha\) 是否在其输出中，执行 \(P'\) 1 分钟看
\(\alpha\) 是否在其输出中</li>
<li>类似上面，不过各执行 2 分钟</li>
<li>类似上面，不过各执行 3 分钟</li>
<li>…</li>
</ol>
<p>总会有一个足够大的步数 \(n\) 使得要么 \(P\) 要么 \(P'\) 会输出
\(\alpha\)，则相应返回 yes/no 即可</p>
</div>
</div>
<h3 id="theorem-17g">⚹ Theorem 17G</h3>
<blockquote>
<p>如果 \(\Sigma\)
是一个<strong>可判定</strong>的合式公式集合，那么它的<strong>重言式推论集合（set
of tautological consequences）</strong>
是<strong>有效可枚举（半可判定）</strong>的</p>
</blockquote>
<div class="proof">
<div class="proof-label">
Proof
</div>
<div class="proof-content">
<p>实际上 \(\Sigma\) 只需要有效可枚举的即可，例如枚举出 \(\psi_1,
\psi_2, \psi_3, ...\)，那么对于任意一个合式公式 \(\tau\)，
可逐一测试</p>
<p>\[
\begin{split}
\emptyset \vDash \tau \\
\{\psi_1\} \vDash \tau \\
\{\psi_1, \psi_2\} \vDash \tau \\
\{\psi_1, \psi_2, \psi_3\} \vDash \tau \\
...
\end{split}
\]</p>
<p>如果在某一步成立，则返回 yes，否则一直测试下去</p>
<p>这里有一个问题，就是假如 \(\Sigma \vDash
\tau\)，此一过程是否会一直执行下去不停机呢？答案是不会，因为 <a
href="#corollary-17a">Compactness Corollary</a>，存在有限子集 \(\Sigma_0
\subseteq \Sigma\) 使得 \(\Sigma_0 \vDash \tau\)</p>
</div>
</div>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>因为命题符号（sentence
symbol）以及链接符组成的集合是可数集（coutably infinite set）： \[
\begin{split}
s_1 &amp; = \neg \\
s_2 &amp; = \wedge \\
s_3 &amp; = \vee \\
s_4 &amp; = \rightarrow \\
s_5 &amp; = \leftrightarrow \\
s_6 &amp; = A_1 \\
s_7 &amp; = A_2 \\
s_8 &amp; = A_3 \\
    &amp; ...
\end{split}
\] 则由有限个这些符号组成的合式公式的集合也是可数集；
简单地说，任意一个合式公式可以表述为一个有限序列 \(\langle s_{i_1},
s_{i_2}, ..., s_{i_n} \rangle\)， 它可以跟自然数 \(2^{i_1} \cdot 3^{i_2}
\cdot ... \cdot P_n^{i_n}\) 一一对应（其中 \(P_n\) 是第 \(n\) 个素数）<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>另一种证明方法是书中 Exercise 1:
<strong>假设 \(\Sigma\) 有限可满足， 则要么 \(\Sigma ; \alpha\) 要么
\(\Sigma ; \neg \alpha\) 也有限可满足</strong>； 反证法，
假设不是，则存在有限子集 \(\Sigma_1 \subseteq \Sigma\) 以及 \(\Sigma_2
\subseteq \Sigma\)，使得 \(\Sigma_1 ; \alpha\) <sup>(1)</sup> 以及
\(\Sigma_2 ; \neg \alpha\) <sup>(2)</sup> 均
<strong>无法被满足</strong>；现在我们考虑 \(\Sigma_1 \cup
\Sigma_2\)，由有限可满足性， 知存在赋值 \(v\) 满足该集合（也就是同时满足
\(\Sigma_1\) 和 \(\Sigma_2\)），\(v\) 如果可满足 \(\alpha\) 则与
<sup>(1)</sup> 矛盾， \(v\) 如果不满足 \(\alpha\) 则与 <sup>(2)</sup>
矛盾<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>\(\alpha\) 和 \(\neg \alpha\)
不能同时在 \(\Delta\) 中，因为它们组成的子集无法被满足<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>这里 \(\square\)
表示连接符（e.g. \(\wedge, \vee, \rightarrow, \leftrightarrow\)）<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>以 \(\wedge\) 为例： \[
\begin{array}{c c c c c c}
\bar{v}(\psi_1) &amp;
\Lambda_{\bar{v}(\psi_1)}(\psi_1) \in \Delta &amp;
\bar{v}(\psi_2) &amp;
\Lambda_{\bar{v}(\psi_2)}(\psi_2) \in \Delta &amp;
\bar{v}(\psi_1 \wedge \psi_2) &amp; \Lambda_{\neg (\bar{v}(\psi_1 \wedge
\psi_2))}(\psi_1 \wedge \psi_2) \in \Delta \\
T &amp; \psi_1 \in \Delta &amp; T &amp; \psi_2 \in \Delta &amp; T &amp;
\neg (\psi_1 \wedge \psi_2) \in \Delta \\
T &amp; \psi_1 \in \Delta &amp; F &amp; \neg \psi_2 \in \Delta &amp; F
&amp; \psi_1 \wedge \psi_2 \in \Delta \\
F &amp; \neg \psi_1 \in \Delta &amp; T &amp; \psi_2 \in \Delta &amp; F
&amp; \psi_1 \wedge \psi_2 \in \Delta \\
F &amp; \neg \psi_1 \in \Delta &amp; F &amp; \neg \psi_2 \in \Delta
&amp; F &amp; \psi_1 \wedge \psi_2 \in \Delta \\
\end{array}
\] 例如第二行要成立，则 \(\{\psi_1, \neg \psi_2, \psi_1 \wedge \psi_2 \}
\in \Delta\)，但这个子集是不可满足的<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>对于一个式子 \(\psi\)，全体赋值 \(v\)
可以划分为两部分：要么满足 \(\psi\) 要么满足 \(\neg \psi\)，泾渭分明；
它跟一个合式公式集合 \(\Sigma\) 的关系可用下面两图直观表达</p>
<p><img src="entail.png" /></p>
<p>\(\Sigma \vDash \psi\)，即能满足 \(\Sigma\) 的赋值集是能满足 \(\psi\)
的赋值集的子集， 当且仅当能满足 \(\Sigma\) 的赋值集跟能满足 \(\neg
\psi\) 的赋值集完全没交集，即 \(\Sigma; \neg \psi\) 不可满足</p>
<p><img src="not-entail.png" /></p>
<p>\(\Sigma \nvDash \psi\)，即存在能满足 \(\Sigma\) 但不能满足 \(\psi\)
的赋值（红点部分），即 \(\Sigma; \neg \psi\) 可满足<a href="#fnref6"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

  </article>

  <div id="content-comment">
    
      <script type="text/javascript" src="/res/script/giscus.min.48297e6d9ad98018d4602f441f423964aa55b45d7a29992f53eaf5ece0fa3e89.js"></script>
      <script>
        createGiscus({
          "repo":               "huangjunwen\/huangjunwen.github.io",
          "repoId":             "MDEwOlJlcG9zaXRvcnk3Njg1MDM5OQ==",
          "category":           "Announcements",
          "categoryId":         "DIC_kwDOBJSk384CXDLR",
          "mapping":            "pathname",
          "strict":             "0",
          "reactionsEnabled":   "1",
          "inputPosition":      "top",
          "lightTheme":         "https:\/\/huangjunwen.github.io\/res\/style\/giscus-light-gruvbox-soft.min.f7a2061b6bd090f275d7d33c31f03a76acd5cb69ad2bf6ad0b1089fc80e2cb4e.css",
          "darkTheme":          "https:\/\/huangjunwen.github.io\/res\/style\/giscus-dark-gruvbox-soft.min.ca9fff96b0a35ad373d69275fad63708399bbc5c733891675010df782733e809.css",
          "containerId":        "content-comment"
        });
      </script>
    
  </div>


        </div>
      </div>
      <div id="main-right" class="hide-xs hide-sm col-2-md col-3-lg">
        
  
  <div id="content-toc" class="toc hide-md"></div>
  

      </div>
    </div>

    
    <div id="footer" class="text-center">
      <p>
        Powered By <a href="https://gohugo.io/">Hugo</a>/<a href="https://jenil.github.io/chota">Chota</a>,
        Generated Using <a href="https://github.com/huangjunwen/mdtool">MDTool</a>
      </p>
      <p>&copy; 2023. All rights reserved</p>
    </div>

    
  
    <link rel="stylesheet" href="/res/libs/tocbot/css/tocbot.css"></link>
    <style>
    #content-toc {
      position: -webkit-sticky;
      position: sticky;
      top: 7rem;
      padding-left: 2rem;
      padding-right: 1rem;
    }

    #content-toc a.toc-link {
      color: var(--font-color);
    }

    #content-toc a.toc-link.is-active-link {
      color: var(--color-darkGrey);
    }

    #content-toc a.toc-link::before {
      background-color: var(--bg-color);
    }

    #content-toc a.toc-link.is-active-link::before {
      background-color: var(--color-primary);
    }
    </style>
    <script src="/res/libs/tocbot/js/tocbot.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', (ev) => {
      tocbot.init({
        tocSelector: '#content-toc',
        contentSelector: '#main-center',
        ignoreSelector: '.no-toc',
        headingSelector: 'h1, h2, h3, h4, h5, h6',
        hasInnerContainers: false,
        headingsOffset: 80,
        scrollSmoothOffset: -80
      });
    });
    </script>
  
  
    <script type="text/javascript" src="/res/libs/anchorjs/js/anchor.min.js"></script>
    <script>anchors.add('#main-body h1, #main-body h2, #main-body h3, #main-body h4, #main-body h5, #main-body h6, #main-body dt');</script>
  

  </body>
</html>
