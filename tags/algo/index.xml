<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algo on Coder Papa</title>
    <link>http://127.0.0.1:1313/tags/algo/</link>
    <description>Recent content in algo on Coder Papa</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 12 Sep 2020 12:23:00 +0800</lastBuildDate><atom:link href="http://127.0.0.1:1313/tags/algo/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kademlia 简介</title>
      <link>http://127.0.0.1:1313/notes/archive/kademlia/</link>
      <pubDate>Sat, 12 Sep 2020 12:23:00 +0800</pubDate>
      
      <guid>http://127.0.0.1:1313/notes/archive/kademlia/</guid>
      <description>Kademlia 是一种 p2p 网络的分布式哈希表 (DHT: distributed hash table). 有别于单机版的 hash table, p2p DHT 需要将 key-value 键值对存放在大量的 (但不稳定的) p2p 节点上的, 并提供远程的 (RPC) 存取方法.
键空间 (Key Space) Kademlia 的 key 是 n-bit 的 unsigned int, 故取值范围为 \([0, 2^n-1]\). 例如原论文中使用 160 bits, 又如 ipfs 使用的是 256 bits.
在键空间上定义 “距离” 为两个 key 之间的 异或 (结果仍然为 n-bit unsigned int):
\[ Dis(A, B) = A ⊕ B \]
NOTE: 使用异或作为距离有一些数学属性, 见下面详述, 这里先跳过，我们先看个例子
上图是一个 n 为 4 的示例，其 key 取值为 [0, 15] （或 [0b0000, 0b1111]），以一棵满二叉树的形式呈现.</description>
    </item>
    
    <item>
      <title>Shamir Secret Sharding</title>
      <link>http://127.0.0.1:1313/notes/archive/shamir-secret-sharding/</link>
      <pubDate>Sun, 23 Apr 2017 09:27:43 +0800</pubDate>
      
      <guid>http://127.0.0.1:1313/notes/archive/shamir-secret-sharding/</guid>
      <description>Hashicorp 这家公司的产品都很有意思，其中 Vault 是一个用来集中管理敏感信息（密码，各种 token，证书，key 等等）的工具。
Vault server 运行起来之后有两种状态：seal/unseal (密封/解封) ，这是因为：
Vault 的数据是加密储存在磁盘上的：由 encryption key 加密，这个 encryption key 是由 master key 加密储存在磁盘上，而 master key 是不存放在磁盘上。所以当 Vault server 刚启动时，由于 master key 未知，故 encryption key 以及实际数据都是无法被解密访问的，这种状态就称之为seal (密封) ，unseal(解封) 就是重建 master key 的过程。
由于 master key 太重要了，Vault 使用所谓的 Shamir’s Secret Sharing 算法把这个 master key 切分并分发给 n 个人，只有当这 n 个人里的最少 k 个人授权提供他们持有的部分，vault 才能重构出这个 master key，这个算法挺有趣，所以记录下来：
目标 密码 \(S\) 需要切分成 \(n\) 份： \(S_1, S_2, ... S_n\)</description>
    </item>
    
    <item>
      <title>RSA 简介</title>
      <link>http://127.0.0.1:1313/notes/archive/rsa/</link>
      <pubDate>Tue, 24 Jan 2017 11:52:55 +0800</pubDate>
      
      <guid>http://127.0.0.1:1313/notes/archive/rsa/</guid>
      <description>主要算法 RSA 的原理是在于能够找到三个很大的正整数 \(e,d,n\) 使得对于任何 \(0 \le m \lt n\)：
\[ (m^e)^d \equiv m \pmod{n} \]
其中公钥为 \((n,e)\)，可以发送给任何人；私钥为 \((n,d)\)，只能由所有者掌握。RSA 支持 4 种操作：加密/解密，签名/验证签名。
加密 首先用一些编码手段把需要加密的信息转换成整数 \(m\)，用公钥中的两个参数计算
\[ c = m^e \pmod{n} \]
其中 \(c\) 就是加密后的信息了。
解密 中学知识温习时间：
\[ \begin{align} ab \pmod{n} &amp;amp;= (xn+a_r)(yn+b_r) \pmod{n} \\ &amp;amp;= a_r b_r \pmod{n} \\ &amp;amp;= (a \pmod{n})(b \pmod{n}) \pmod{n} \end{align} \]
即在模运算中，只要算余数就可以了。
因此，由私钥所有者计算
\[ \begin{align} c^d \pmod{n} &amp;amp;= (m^e \pmod{n})^d \pmod{n} \\ &amp;amp;= (m^e)^d \pmod{n} \\ &amp;amp;= m \pmod{n} \end{align} \]</description>
    </item>
    
  </channel>
</rss>
