<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tool on Coder Papa</title>
    <link>http://127.0.0.1:1313/tags/tool/</link>
    <description>Recent content in tool on Coder Papa</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 16 Apr 2022 03:24:27 +0000</lastBuildDate><atom:link href="http://127.0.0.1:1313/tags/tool/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PLFA 准备篇</title>
      <link>http://127.0.0.1:1313/notes/type-theory/plfa-prepare/</link>
      <pubDate>Sat, 16 Apr 2022 03:24:27 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/notes/type-theory/plfa-prepare/</guid>
      <description>准备开始看 Programming Language Foundations in Agda (plfa)，需要准备环境
安装 haskell Agda 是用 haskell 写的，故首先需要按照 haskell，ubuntu 20 上最简单的方式就是
$ sudo apt install haskell-platform 安装 Agda 我用 haskell cabal 安装 agda
$ cabal v2-update $ cabal v2-install Agda-2.6.1.3 $ cabal v2-install --lib ieee754  选 2.6.1.3 这个版本是跟着 plfa 里的版本要求的
 PLFA is tested against specific versions of Agda and the standard library, which are shown in the badges above. Agda and the standard library change rapidly, and these changes often break PLFA, so using older or newer versions usually causes problems</description>
    </item>
    
    <item>
      <title>新博客</title>
      <link>http://127.0.0.1:1313/posts/2022/new-blog/</link>
      <pubDate>Sat, 19 Feb 2022 09:24:49 +0000</pubDate>
      
      <guid>http://127.0.0.1:1313/posts/2022/new-blog/</guid>
      <description>花了相当相当多时间重新建设自己的内容管理系统，总算大致完成（https://github.com/huangjunwen/mdtool），记录一下
需求 大致如下
内容应该可以很容易跨平台发布，例如除了本身作为博客的网站外，也能发布到微信公众号或其他内容平台， 甚至可以单独输出成文档 写作时要有实时反馈 内容使用的格式不能过于依赖专有或特定软件 仅使用开源工具  格式 Markdown 熟悉，简单，广泛应用
 https://www.markdownguide.org/basic-syntax/ https://www.markdownguide.org/extended-syntax/  Tex 功能强大，表达丰富，不过需要些时间学习；另外 markdown 中也可以嵌入 math mode 的公式，这已经解决很大一部分问题了
Svg 配图首选，缩放无损，文本可编辑，众多编辑器可用1
工具 Hugo 速度快，编辑即可看到效果
Pandoc pandoc 也是可以作为 hugo 的 markdown 渲染引擎的 2，用它有多个好处
 能识别 latex 式的 math mode（$...$/$$...$$） 可以写 filter！用 外部程序 或者 lua 脚本 直接修改 pandoc 的 ast pandoc 本身就是用来转换格式的（e.g. markdown -&amp;gt; pdf） 更多扩展  整合 整合起来就是：内容为 markdown 格式，尽量少使用专有的扩展，pandoc 负责将其转换格式，其中最主要的 html 格式则交由 hugo + js + css 进一步处理及呈现</description>
    </item>
    
    <item>
      <title>写了一个 MySQL 数据表和查询的 go 代码生成器</title>
      <link>http://127.0.0.1:1313/posts/archive/sqlw-mysql/</link>
      <pubDate>Mon, 10 Sep 2018 20:51:26 +0800</pubDate>
      
      <guid>http://127.0.0.1:1313/posts/archive/sqlw-mysql/</guid>
      <description>项目地址 https://github.com/huangjunwen/sqlw-mysql
动机 最近这段时间开始用 go 写网站，遇到各种新老问题。其中一个老问题是如何访问 MySQL 数据库。
使用 ORM (Object Relationship Mapping) 大致浏览了一些热门的实现，感觉不是很合眼缘，跟动态语言的实现（例如 SQLAlchemy ）差不少。
ORM 的特点在于使用程序员熟悉的对象概念抽象数据库关系，使之成为可编程的对象，提供使用上的便利：
 构造查询的便利，用户一般只需要指定需要查询的对象（一般对应数据库表），或者关系（一般对应 JOIN），还可以按需要增添查询条件，ORM 即可推导出需要执行的语句：  sess.query(User) # SELECT user.id, ... FROM user sess.query(Employee.User) # SELECT employee.id, ... FROM employee JOIN user ON ... sess.query(User).filter(User.name==xxx) # SELECT user.id, ... FROM user WHERE name=xxx sess.query(User).options(joinedload(Employee)).order_by(...) # ...  查询后的便利，结果集会被重新组装成对象，后续仍只需继续在这些对象上操作即可。  这样理想状态下涉及数据库的操作就被完全封装到一个闭环里头。然而数据库关系其实并不简单，建立一个表达力十足的映射模型即是使用 python 这种表达力很强的动态语言都很复杂（看看这个函数），何况 go 这种既缺乏元编程能力也缺乏语法糖的语言呢。
因此我所见的实现往往只能退而求其次，只实现一些基本常用的功能。
直接使用 SQL 除了使用 ORM 另外一种方法是直接面对关系数据库/SQL 本身，例如有很多人（声称）直接使用 sqlx，但我感觉全部手写会不会也挺麻烦重复的呢？
所以有一些工具能帮忙生成代码，例如 xo，连接上数据库直接导出 schema 就能生成基本的 CRUD 访问代码，同时也可以根据它的 SQL DSL 生成 SQL 的 wrapper code。整个过程一目了然，没有层层封装的不透明感，生成代码的效率也高，虽然需要手写 SQL，但代码生成过程是经过实际数据库验证的，这就相当可靠了。</description>
    </item>
    
    <item>
      <title>Vault Database Secret Backend</title>
      <link>http://127.0.0.1:1313/notes/unclassified/vault-database-secret-backend/</link>
      <pubDate>Sat, 10 Jun 2017 16:46:36 +0800</pubDate>
      
      <guid>http://127.0.0.1:1313/notes/unclassified/vault-database-secret-backend/</guid>
      <description>在当前版本（v0.7.2）这个 backend 还处于 beta 状态；这个 backend 应该是用来统一之前版本中各种数据库的 secret backend 的；使用前需要挂载 vault mount database，这里用 MySQL 来演示它的主要工作流程：
 写入数据库配置，路径在 database/config/$db_name ，主要参数有：  db_name 这个配置的名字 plugin_name 指定用何种数据库 driver plugin（mysql/postgres 等） connection_url 指定连接参数（注：这个连接参数是用来连数据库以创建用户的，需要有对应的权限） allowed_roles 指定的是允许哪些角色使用此配置（角色是啥下一步就会说明） 安全考虑：这个路径即使读权限也需要严格限制，因为它包含了相当高权限的数据库用户信息 例子：   $ export db_name=&amp;quot;test&amp;quot; $ export role_name=&amp;quot;test_reader&amp;quot; $ export plugin_name=&amp;quot;mysql-legacy-database-plugin&amp;quot; # mysql 有多个 plugin，它们的区别这是创建的数据库用户名最大长度不一样，因为不同版本用户名长度有变化 $ export connection_url=&amp;quot;root:password@tcp(127.0.0.1:3306)/&amp;quot; # 不要忘了最后的 / $ vault write database/config/$db_name \ &amp;gt; plugin_name=$plugin_name \ &amp;gt; connection_url=$connection_url \ &amp;gt; allowed_roles=&amp;quot;$role_name&amp;quot; ... The following warnings were returned from the Vault server: * Read access to this endpoint should be controlled via ACLs as it will return the connection details as is, including passwords, if any.</description>
    </item>
    
    <item>
      <title>Vault 介绍</title>
      <link>http://127.0.0.1:1313/notes/unclassified/vault/</link>
      <pubDate>Wed, 07 Jun 2017 08:14:18 +0800</pubDate>
      
      <guid>http://127.0.0.1:1313/notes/unclassified/vault/</guid>
      <description>之前一篇文章介绍了 Hashicorp Vault 的解封/密封算法。这篇打算记录一下这个软件的其它方面。当前最新版本为 v0.7.2 。
Vault 是一个相当复杂的系统，总括而言，它是一个集中管理各类敏感信息（如密码/Key/证书等等）的软件（服务）。Vault 采用类似 Unix “一切皆文件” 的方式组织及暴露各类信息：所有操作都是对某个路径的 read/write （实际上是对某个 HTTP 路径 POST/GET/LIST/DELETE 等） ，例如：
 /sys 目录下是各种配置路径，此目录不可被卸载，其下路径各有用途，如 /sys/seal 和 /sys/unseal 这两个路径是用来密封/解封 vault 的。 /secret 目录下挂载的是 Generic Secret Backend，用于存放一般用途的敏感信息，其下路径组织结构由用户自行决定，我们平时实际使用访问最多的应该也是这个。 … 更多目录路径说明可参看 API 文档  读取/写入的数据一般都是 JSON 格式。
Backends Vault 主要由几类 backends 合作组成：
Auth -&amp;gt; Secret -&amp;gt; Storage(Physical) -&amp;gt; Audit
认证 -&amp;gt; 实际操作 -&amp;gt; 落盘储存 -&amp;gt; 日志
Auth(entication) Backend Auth Backend 完成的是认证工作：访问者是谁。有多种可通过挂载添加，默认情况下它们会挂载在 auth/&amp;lt;type&amp;gt; 下，以下是其中一些认证方式：
 token 这个 Backend 是 Vault 的核心认证方式，默认挂载，不可卸载，非常重要，下一小节详细描述 userpass 用户名密码认证 github 用 Github 的认证服务 cert 用 tls 证书认证 approle TODO  Token （令牌） 对外部而言，顾名思义，有了令牌就能通行，它是访问者身份的象征；实际上，Vault 对外 API 中绝大部分（除了像 seal/unseal 这种）都需要令牌才能访问：访问的 HTTP 请求头部需要加上 X-Vault-Token: xxxxxx （命令行其实也是调用 HTTP API 的，Token 保存在 ~/.</description>
    </item>
    
    <item>
      <title>用 iptables 来配置 port knocking</title>
      <link>http://127.0.0.1:1313/posts/archive/port-knocking-using-iptables/</link>
      <pubDate>Tue, 20 Dec 2016 10:20:54 +0800</pubDate>
      
      <guid>http://127.0.0.1:1313/posts/archive/port-knocking-using-iptables/</guid>
      <description>对于正式环境的服务器来说，每当查看到 auth.log 里头那些撞大运的 ssh 登录尝试，心里总是有点惴惴不安的。虽然 public key authentication 号称安全，但是谁说得准呢？而且不知道配置里会不会有错误，要是有多一层的防护总是好的。
以前听说过 Port knocking 这种技术了，大致的思路就是设定一系列随机端口（例如：7421，3411，9088等等）作为暗号，用户在访问服务器之前，要依次“敲”一下这几个端口（即相继发送网络包到这几个端口上），这些端口当然是关闭状态啦，但服务器上可以侦察得到这些敲门，如果暗号对了，就给访问者 ip 开放服务端口（例如22）。
还有一些更高级的，例如在网络包里存放加密信息等，不过这就复杂了，暂且不表。
一般要实现这样的功能，需要有独立的 deamon 程序跑在后台检查日志，但有个问题，如果这个 deamon 不够健壮挂了的话，就再也没人上得去了。
前段时间看到 DigitalOcean 上一篇单纯使用 iptables 就能实现 Port knocking 的教程，不需要单独开发 deamon，只要配置 iptables 的 rules 就能实现这样的功能，觉得很实用，分享在此：
https://www.digitalocean.com/community/tutorials/how-to-configure-port-knocking-using-only-iptables-on-an-ubuntu-vps
不过我用的时候发现个问题，就是 tcp 包在发送的时候，好像一次过会发送多个包，这样敲门的序列就会变成类似：
7421 7421 3411 9088 9088 9088 ... 所以我把 rules 改成接纳每个端口可以连续 N 次，只要下一个不一样的是正确的就可以接受：
#!/bin/bash PORT1=xxxx PORT2=xxxx PORT3=xxxx # reset firewall iptables -F iptables -X iptables -P INPUT ACCEPT iptables -P FORWARD ACCEPT iptables -P OUTPUT ACCEPT # create new chains used by port knocking iptables -N KNOCKING iptables -N GATE1 iptables -N GATE2 iptables -N GATE3 iptables -N PASSED # accept current connections (keep current SSH connections) iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT # accept local machine&amp;#39;s connection iptables -A INPUT -i lo -j ACCEPT # accept http/https or other exported services iptables -A INPUT -p tcp --dport 80 -j ACCEPT iptables -A INPUT -p tcp --dport 443 -j ACCEPT # now pass all other to the KNOCKING chain iptables -A INPUT -j KNOCKING # KNOCKING dispatch iptables -A KNOCKING -m recent --reap --rcheck --seconds 3600 --name AUTH3 -j PASSED iptables -A KNOCKING -m recent --reap --rcheck --seconds 10 --name AUTH2 -j GATE3 iptables -A KNOCKING -m recent --reap --rcheck --seconds 10 --name AUTH1 -j GATE2 iptables -A KNOCKING -j GATE1 iptables -A GATE1 -p tcp --dport $PORT1 -m recent --name AUTH1 --set -j DROP iptables -A GATE1 -j DROP iptables -A GATE2 -p tcp --dport $PORT1 -j DROP # allow $PORT1 duplication iptables -A GATE2 -m recent --name AUTH1 --remove iptables -A GATE2 -p tcp --dport $PORT2 -m recent --name AUTH2 --set -j DROP iptables -A GATE2 -j GATE1 iptables -A GATE3 -p tcp --dport $PORT2 -j DROP # allow $PORT2 duplication iptables -A GATE3 -m recent --name AUTH2 --remove iptables -A GATE3 -p tcp --dport $PORT3 -m recent --name AUTH3 --set -j DROP iptables -A GATE3 -j GATE1 iptables -A PASSED -p tcp --dport $PORT3 -j DROP # allow $PORT3 duplication iptables -A PASSED -p tcp --dport 22 -j ACCEPT iptables -A PASSED -j DROP 另外还有些修改，例如 AUTH3 的时候，允许用户有一个小时（3600秒）的时间可以随意连接 22 端口。</description>
    </item>
    
  </channel>
</rss>
