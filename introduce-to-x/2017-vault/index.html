<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="HJW" />
  <meta name="dcterms.date" content="2017-06-07" />
  <title>Vault 介绍</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!-- latex css begin -->
  <!--<link href="/assets/latex.css/style.min.css" rel="stylesheet" />-->
  <link href="../../assets/latex.css/style.css" rel="stylesheet" />
  <style>
  /* fixes for latex.css */
  .date {
    text-align: center;
  }

  div.sourceCode {
    background: var(--pre-bg-color);
    border-radius: 10px;
  }

  dl dd {
    text-align: left;
  }

  #footnotes {
    margin-top: 1em;
  }

  #footnotes hr:first-child {
    display: none;
  }
  </style>
  <!-- latex css end -->

  <!-- venobox begin -->
  <link rel="stylesheet" href="../../assets/venobox/dist/venobox.min.css" />
  <script src="../../assets/venobox/dist/venobox.min.js"></script>
  <script>
    window.addEventListener("load", (ev) => {
      document.querySelectorAll('img').forEach((img) => {
        const a = document.createElement("a")
        a.href = '#'
        a.setAttribute('data-href', img.src)
        a.classList.add('images')
        img.replaceWith(a)
        a.appendChild(img)
      })
      new VenoBox({
        selector: '.images',
        fitView: true,
      })
    })
  </script>
  <!-- venobox end -->

  <!-- layout begin -->
  <style>
  #sidebar {
    position: fixed;
    top: 0;
    left: 0;
    z-index: 999;
    max-width: 400px;
    width: 80%;
    height: 100%;
    padding: 2rem;
    background-color: #eee;
    box-shadow: 0 10px 20px -4px #000;
    overflow-x: hidden;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #ccc #eee;
    scrollbar-gutter: stable;
    pointer-events: none;
    opacity: 0;
    visibility: hidden;
    transform: translateX(-100%);
    transition: opacity 0.3s ease, visibility 0.2s ease, transform 0.3s ease;
  }
  #sidebar.show {
    pointer-events: all;
    opacity: 1;
    visibility: visible;
    transform: translateX(0);
  }
  #sidebar_toggler {
    position: fixed;
    top: 4vh;
    right: 3vw;
    z-index: 1000;
    width: 2.8rem;
    height: 2.4rem;
    padding: 0.5rem;
    border: solid #999 0.1rem;
    border-radius: 0.4rem;
    background-color: #fff;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    cursor: pointer;
    overflow: hidden;
  }

  #sidebar_toggler span {
    background-color: #999;
    width: 100%;
    height: 0.2rem;
    transition: all 0.3s ease;
    pointer-events: none;
  }
  nav span {
    display: inline-block;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    /*white-space: pre-wrap;*/
    width: 90%;
  }
  nav li:before {
    content: '';
  }
  nav span:before {
    content: "\25CF";
    margin-right: 8px;
  }
  nav .caret {
    cursor: pointer;
    user-select: none; /* Prevent text selection */
  }
  nav .caret::before {
    content: "\25B6";
    color: black;
    display: inline-block;
    margin-right: 6px;
  }
  nav .caret-down::before {
    transform: rotate(90deg);
  }
  nav .collapse {
    display: none;
  }
  nav .bold {
    font-weight: bolder;
  }
  </style>
  <script>
    window.addEventListener("load", (ev) => {
      /* setup sidebar */
      // https://www.cssscript.com/demo/responsive-sidebar-nav-hamburger/
      const sidebar = document.querySelector('#sidebar')
      const sidebarToggler = document.querySelector('#sidebar_toggler')

      sidebarToggler.addEventListener('click', () => {
        sidebar.classList.toggle('show')
      });

      const keywords = document.querySelector('meta[name="keywords"]')
      if (keywords && keywords.content.includes('showSidebar')) {
        sidebar.classList.add('show')
      }

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          sidebar.classList.remove('show')
        }
      })

      window.addEventListener('click', (e) => {
        if (!sidebar.contains(e.target) && !sidebarToggler.contains(e.target)) {
          sidebar.classList.remove('show')
        }
      });

      /* load urls */
      const root2PageDir = "/introduce-to-x/2017-vault"
      const page2RootDir = "../.."
      const sideNavLinks = document.querySelector('#side_navlinks');

      function isPrefixPath(pathPrefix, path) {
        const pp = pathPrefix.split("/").filter((e) => e)
        const p = path.split("/").filter((e) => e)
        return pp.every((e, i) => {
          return i < p.length && p[i] == e
        })
      }

      function buildSideLink(li, node) {
        // span contains the text and link (if provided)
        const span = li.appendChild(document.createElement("span"))
        if (node.url) {
          const a = span.appendChild(document.createElement("a"))
          a.href = page2RootDir + node.url
          a.textContent = node.text
        } else {
          span.textContent = node.text
        }
        span.setAttribute("title", node.text)
        if (isPrefixPath(node.path, root2PageDir)) {
          span.classList.add("bold")
        }

        if (node.children.length > 0) {
          // if has children, then add caret and append a nested <ul> for children
          span.classList.add("caret")
          const ul = li.appendChild(document.createElement("ul"))
          ul.classList.add("nested")
          // do not collapse containing dir
          if (isPrefixPath(node.path, root2PageDir)) {
            span.classList.add("caret-down")
          } else {
            ul.classList.add("collapse")
          }
          node.children.forEach((child) => {
            const l = ul.appendChild(document.createElement("li"))
            buildSideLink(l, child)
          })
        }
      }

      async function loadSideLinks() {
        const resp = await fetch("../../urls.json")
        const data = await resp.json()
        // console.log(data)
        const root = sideNavLinks.appendChild(document.createElement("ul"))
        data.children.forEach((child) => {
          buildSideLink(root.appendChild(document.createElement("li")), child)
        })

        const toggler = root.getElementsByClassName("caret")
        for (let i=0; i<toggler.length; i++) {
          toggler[i].addEventListener("click", function () {
            this.parentElement.querySelector(".nested").classList.toggle("collapse")
            this.classList.toggle("caret-down")
            return false
          })
        }
      }

      loadSideLinks()
    })
  </script>
  <!-- layout end -->
</head>
<body>
<!-- sidebar begin -->
<aside id="sidebar">
  <div class="sidebar_content sidebar_head">
    <h1>Content</h1>
  </div>
  <div class="sidebar_content sidebar_body">
    <nav id="side_navlinks" class="side_navlinks">
      <!--<ul>
        <li><a href="#">Home</a></li>
        <li><a href="#">About</a></li>
        <li><a href="#">Services</a></li>
        <li><a href="#">Portfolio</a></li>
        <li><a href="#">Contact</a></li>
      </ul>-->
    </nav>
  </div>
</aside>
<div id="sidebar_toggler">
  <span></span>
  <span></span>
  <span></span>
</div>
<!-- sidebar end -->

<!--main article begin-->
<article>
<header id="title-block-header">
<h1 class="title">Vault 介绍</h1>
<p class="author">HJW</p>
<p class="date">2017-06-07</p>
</header>
<p>之前一篇<a
href="/how-x-works/2017-shamir-secret-sharding/">文章</a>介绍了 <a
href="https://www.vaultproject.io/">Hashicorp Vault</a>
的解封/密封算法。这篇打算记录一下这个软件的其它方面。当前最新版本为
v0.7.2 。</p>
<p>Vault
是一个相当复杂的系统，总括而言，它是一个集中管理各类敏感信息（如密码/Key/证书等等）的软件（服务）。Vault
采用类似 Unix <a
href="https://en.wikipedia.org/wiki/Everything_is_a_file">“一切皆文件”</a>
的方式组织及暴露各类信息：所有操作都是对某个路径的 read/write
（实际上是对某个 HTTP 路径 POST/GET/LIST/DELETE 等） ，例如：</p>
<ul>
<li><code>/sys</code>
目录下是各种配置路径，此目录不可被卸载，其下路径各有用途，如
<code>/sys/seal</code> 和 <code>/sys/unseal</code>
这两个路径是用来密封/解封 vault 的。</li>
<li><code>/secret</code> 目录下挂载的是 <a
href="https://www.vaultproject.io/docs/secrets/generic/index.html">Generic
Secret
Backend</a>，用于存放一般用途的敏感信息，其下路径组织结构由用户自行决定，我们平时实际使用访问最多的应该也是这个。</li>
<li>… 更多目录路径说明可参看 <a
href="https://www.vaultproject.io/api/index.html">API 文档</a></li>
</ul>
<p>读取/写入的数据一般都是 JSON 格式。</p>
<h2 id="backends">Backends</h2>
<p>Vault 主要由几类 backends 合作组成：</p>
<p>Auth -&gt; Secret -&gt; Storage(Physical) -&gt; Audit</p>
<p>认证 -&gt; 实际操作 -&gt; 落盘储存 -&gt; 日志</p>
<h3 id="authentication-backend">Auth(entication) Backend</h3>
<p>Auth Backend
完成的是认证工作：访问者是谁。有多种可通过挂载添加，默认情况下它们会挂载在
<code>auth/&lt;type&gt;</code> 下，以下是其中一些认证方式：</p>
<ul>
<li><a href="https://www.vaultproject.io/docs/auth/token.html">token</a>
这个 Backend 是 Vault
的核心认证方式，默认挂载，不可卸载，非常重要，下一小节详细描述</li>
<li><a
href="https://www.vaultproject.io/docs/auth/userpass.html">userpass</a>
用户名密码认证</li>
<li><a
href="https://www.vaultproject.io/docs/auth/github.html">github</a> 用
Github 的认证服务</li>
<li><a href="https://www.vaultproject.io/docs/auth/cert.html">cert</a>
用 tls 证书认证</li>
<li><a
href="https://www.vaultproject.io/docs/auth/approle.html">approle</a>
<em>TODO</em></li>
</ul>
<h4 id="token-令牌">Token （令牌）</h4>
<p>对外部而言，顾名思义，有了令牌就能通行，它是访问者身份的象征；实际上，Vault
对外 API 中绝大部分（除了像 seal/unseal 这种）都需要令牌才能访问：访问的
HTTP 请求头部需要加上 <code>X-Vault-Token: xxxxxx</code>
（命令行其实也是调用 HTTP API 的，Token 保存在
<code>~/.vault_token</code> 里以供其使用）</p>
<p>对内部而言，Token 是 Vault
里多个组件间的结合点，关联对应许多信息：</p>
<ul>
<li>树状层次：除了 root tokens 和 orphan tokens 外都有父 token，故所有
tokens 形成一个树（森林）状层次结构，当父 token 被吊销时，其所有子孙
tokens 都会同时被吊销</li>
<li>限时：token
是有使用时限的（TTL），超时时会被吊销，可以续租延长时限的（但不超过某个最大值），也可以是周期性的
token（可通过周期性地续租无限延长使用时间）</li>
<li>限次：token
可以限制使用次数，默认是不限制，超过使用次数后会被吊销，这个可以用作实现
one-time-password</li>
<li>访问控制策略（Access Control Policies）：这是最关键的，每个 token
都关联一个访问控制策略列表（如
<code>["default", "dev"]</code>），访问控制策略就是 Vault
里头的权限控制机制，例如 <code>default</code> 策略是这样的：</li>
</ul>
<pre class="shell"><code>$ vault policies default  # 查看名为 default 的控制策略

# Allow tokens to look up their own properties
path &quot;auth/token/lookup-self&quot; {
    capabilities = [&quot;read&quot;]
}

# Allow tokens to renew themselves
path &quot;auth/token/renew-self&quot; {
    capabilities = [&quot;update&quot;]
}

# Allow tokens to revoke themselves
path &quot;auth/token/revoke-self&quot; {
    capabilities = [&quot;update&quot;]
}

# Allow a token to look up its own capabilities on a path
path &quot;sys/capabilities-self&quot; {
    capabilities = [&quot;update&quot;]
}

...
</code></pre>
<p>归功于“一切皆文件”的统一设计，能干什么不能干什么（create/read/update/delete/list/sudo/deny）都统一到一组路径上的读写权限。详情可参看
<a href="https://www.vaultproject.io/docs/concepts/policies.html"
class="uri">https://www.vaultproject.io/docs/concepts/policies.html</a></p>
<p>整个流程应该是这样子的：用户（人/机器）携带着令牌调用某个 API，Vault
检查这个令牌是否已被吊销，是否超过使用限制，访问的操作/路径是否被允许，如果都通过了这些检查，才会实际执行操作。</p>
<p>那么好了，令牌本身又是从哪里来的呢？方法有几个：</p>
<ul>
<li>root tokens 可以在 Vault 初始化的时候获得，也可以在之后通过
<code>vault generate-root</code> 命令或 <a
href="https://www.vaultproject.io/api/system/generate-root.html">/sys/generate-root</a>
API 创建新的（需要 unseal key），root token 是 token 中的
superuser，啥都可以做，且一般没有超时时间</li>
<li>通过 <code>vault token-create</code> 命令或 <a
href="https://godoc.org/github.com/hashicorp/vault/api#TokenAuth.Create">/auth/token/create</a>
API 为当前 token 手动创建子 token，子 token 的访问控制策略只能是当前
token 的子集</li>
<li>其它 auth backends 完成对认证后，其实返回的也是
token（所以从这个角度看，Vault 其实就只有 token
一种认证方式），至于返回的是什么样的 token，则决定于这个 auth backend
的配置是怎么样的；例如 Github 可以关联某个 team 或者某个 user
到指定访问控制策略，当这个 team 的成员或这个用户用 Github 的 Personal
Access Token 完成认证后，就返回关联此策略的一个 token</li>
</ul>
<p>关于 token 的更详细文档可以参看这里： <a
href="https://www.vaultproject.io/docs/concepts/tokens.html"
class="uri">https://www.vaultproject.io/docs/concepts/tokens.html</a></p>
<h3 id="secret-backend">Secret Backend</h3>
<p>用来存放（生成）秘密的地方；不同的 backend
类似于不同的虚拟文件系统（tmpfs，udev
等），可以挂载到不同的目录，读写到不同的 backend
下会有各自不同的作用，如：</p>
<ul>
<li><a
href="https://www.vaultproject.io/api/secret/generic/index.html">generic</a>
前文也提及过，一般用途的 backend</li>
<li><a
href="https://www.vaultproject.io/docs/secrets/databases/index.html">database</a>
用来管理数据库连接信息，具体参看另一篇<a
href="../vault-database-secret-backend/">博文</a></li>
<li><a
href="https://www.vaultproject.io/api/secret/pki/index.html">pki</a>
用来管理（生成） X.509 证书 <em>TODO</em></li>
<li><a
href="https://www.vaultproject.io/api/secret/cubbyhole/index.html">cubbyhole</a>
类似于 generic secret backend 可以存放任意秘密，但不同之处在于它是 token
scoped 的
<ul>
<li>解释：举个类比，很多 Unix 系统有一个文件夹
<code>/dev/fd</code>，像一个私有的空间，每一个进程访问都只能看到本进程的打开了的文件描述符；cubbyhole
类似于此，每一个 token
能访问到的都是一个只有自己能访问到的私有空间，当这个 token
销毁的时候，存储在这里面的所有秘密也一并被销毁</li>
<li>用处：例如我们从 Vault
中读取了一些秘密，这个秘密可能会通过很多中间环节才能送到最终的使用者手上，中间环节越多，泄漏的可能性就越大（例如不小心被
log 下来了等），那么可以通过创建一个寿命非常短（例如几秒）且只能用一次的
token，把密码放到此 token 的 cubbyhole 里，中间环节传输的则是这个
token，即使泄漏了，由于其限时限次，秘密泄漏的可能性就大大降低了，同时如果泄漏了，日志里面必定会有所记录（偷取访问一次/正常访问一次，第二次失败），这是所谓
<a
href="https://www.vaultproject.io/docs/secrets/cubbyhole/index.html#response-wrapping">Response
Wrapping</a>；其实这不就有点像 OAuth2 的流程一样，拿一个很短命的 code
去换取 Access Token （秘密）</li>
<li><a
href="https://www.hashicorp.com/blog/cubbyhole-authentication-principles"
class="uri">https://www.hashicorp.com/blog/cubbyhole-authentication-principles</a></li>
<li><a
href="https://www.vaultproject.io/docs/secrets/cubbyhole/index.html"
class="uri">https://www.vaultproject.io/docs/secrets/cubbyhole/index.html</a></li>
</ul></li>
</ul>
<h3 id="storage-physical-backend">Storage (Physical) Backend</h3>
<p>数据真正落盘的地方（注：到达 Storage Backend
时，数据都已经处于加密状态了，安全并不依赖于 Storage backend，实际上它是
untrusted 的，下面代码里有提到），需要在服务启动时在<a
href="https://www.vaultproject.io/docs/configuration/storage/index.html">配置</a>里面指定；这类
backend 同样有很多种，例如：</p>
<ul>
<li><a
href="https://www.vaultproject.io/docs/configuration/storage/in-memory.html">inmem</a>
存放在内存中（dev 模式下即是使用 inmen backend
的，一旦重启，数据就丢失了）</li>
<li><a
href="https://www.vaultproject.io/docs/configuration/storage/filesystem.html">file</a>
直接存放在本地文件里</li>
<li><a
href="https://www.vaultproject.io/docs/configuration/storage/mysql.html">mysql</a>
存放在 MySQL 数据库里</li>
<li><a
href="https://www.vaultproject.io/docs/configuration/storage/consul.html">consul</a>/<a
href="https://www.vaultproject.io/docs/configuration/storage/etcd.html">etcd</a>
存放在 Key-Value 集群中（高可用）</li>
</ul>
<p>例如使用 mysql backend，vault init
后可以看到数据库里头实际上创建了一个表而已，此表就两个字段
<code>vault_key</code> 和 <code>vault_value</code>:</p>
<ul>
<li><code>vault_key</code> 是形如 <code>sys/policy/default</code>
<code>logical/12345678-1234-1234-1234-123456790abc/ca</code>
等等这类内部路径名称。注意：路径是没有加密的，所以 Vault
的文档某个地方（我忘了在哪里了）指出不要把敏感信息暴露在路径上</li>
<li><code>vault_value</code>
大部分是加密后的二进制数据，也有些是明文的，如
<code>core/seal-config</code> 记录密封算法跟参数：</li>
</ul>
<div class="sourceCode" id="cb2"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span><span class="dt">&quot;type&quot;</span><span class="fu">:</span><span class="st">&quot;shamir&quot;</span><span class="fu">,</span><span class="dt">&quot;secret_shares&quot;</span><span class="fu">:</span><span class="dv">5</span><span class="fu">,</span><span class="dt">&quot;secret_threshold&quot;</span><span class="fu">:</span><span class="dv">3</span><span class="fu">,</span><span class="dt">&quot;pgp_keys&quot;</span><span class="fu">:</span><span class="kw">null</span><span class="fu">,</span><span class="dt">&quot;nonce&quot;</span><span class="fu">:</span><span class="st">&quot;&quot;</span><span class="fu">,</span><span class="dt">&quot;backup&quot;</span><span class="fu">:</span><span class="kw">false</span><span class="fu">,</span><span class="dt">&quot;stored_shares&quot;</span><span class="fu">:</span><span class="dv">0</span><span class="fu">}</span></span></code></pre></div>
<p>这部分信息是在没解封前就要用到的，所以只能用明文；我尝试了下改了参数，例如把
<code>secret_threshold</code> 改成 1 看看能不能只要一个 key
就能解封，结果…当然是不能啦 :-)</p>
<p>看了一下相关的代码，发现其实这部分很好理解，实际上只要提供以下这个 <a
href="https://godoc.org/github.com/hashicorp/vault/physical#Backend">interface</a>
就能用作 storage backend 了（其实就是一个可以枚举的 Key-Value store
即可）：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Backend is the interface required for a physical</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">// backend. A physical backend is used to durably store</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">// data outside of Vault. As such, it is completely untrusted,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">// and is only accessed via a security barrier. The backends</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">// must represent keys in a hierarchical manner. All methods</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">// are expected to be thread safe.</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Backend <span class="kw">interface</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Put is used to insert or update an entry</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    Put<span class="op">(</span>entry <span class="op">*</span>Entry<span class="op">)</span> <span class="dt">error</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Get is used to fetch an entry</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    Get<span class="op">(</span>key <span class="dt">string</span><span class="op">)</span> <span class="op">(*</span>Entry<span class="op">,</span> <span class="dt">error</span><span class="op">)</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Delete is used to permanently delete an entry</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    Delete<span class="op">(</span>key <span class="dt">string</span><span class="op">)</span> <span class="dt">error</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// List is used ot list all the keys under a given</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// prefix, up to the next prefix.</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    List<span class="op">(</span>prefix <span class="dt">string</span><span class="op">)</span> <span class="op">([]</span><span class="dt">string</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>注意这里提到的 “As such, it is completely untrusted, …”</p>
<h3 id="audit-backend">Audit Backend</h3>
<p>记日志的，对于敏感信息，日志会进行 HMAC-SHA256
哈希，这样做可以避免暴露明文但仍然能进行对照检查；另外如果启动了至少一个
audit backends 的话，对 Vault
的每一个请求都会<strong>阻塞</strong>直到其中一个日志完成记录，这样就能保证没有任何的操作不被记录下来</p>
</article>
<!--main article end-->

</body>
</html>
