<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jayven@dev</title>
    <link>//huangjunwen.github.io/index.xml</link>
    <description>Recent content on Jayven@dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>&amp;copy; 2017 &lt;a href=&#34;mailto:kassarar@gmail.com&#34;&gt;Huang JunWen&lt;/a&gt;; All rights reserved.</copyright>
    <lastBuildDate>Thu, 15 Mar 2018 09:05:51 +0800</lastBuildDate>
    <atom:link href="//huangjunwen.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Greenlet 笔记</title>
      <link>//huangjunwen.github.io/post/2018/greenlet/</link>
      <pubDate>Thu, 15 Mar 2018 09:05:51 +0800</pubDate>
      
      <guid>//huangjunwen.github.io/post/2018/greenlet/</guid>
      <description>

&lt;p&gt;很多年前有一段时间对协程很感兴趣，于是去研究 &lt;a href=&#34;https://github.com/python-greenlet/greenlet&#34;&gt;Greenlet&lt;/a&gt; 的实现原理，记录在 google code 上（google code 关停后导出到 &lt;a href=&#34;https://github.com/huangjunwen/libhjw/blob/wiki/notes_on_greenlet.md&#34;&gt;Github&lt;/a&gt; 上了），这两天跟某人介绍这个东西的时候翻出来，自己都不是很明白了，果然贴代码的笔记不是好笔记&amp;hellip; 决定再写一篇更偏向原理的&lt;/p&gt;

&lt;h4 id=&#34;原理&#34;&gt;原理&lt;/h4&gt;

&lt;p&gt;我们知道，操作系统会给每一个线程分配一个独立的堆栈，它们各自独立运作，记录着该线程的各类运行状态：如函数本地变量，函数返回地址，寄存器状态等等各种上下文；从这个角度看，堆栈几乎就等价于线程&lt;/p&gt;

&lt;p&gt;那么假如想要在用户态实现轻量级的类线程，就同样需要给它们分配独立堆栈，并提供方法在它们之间切换&lt;/p&gt;

&lt;p&gt;Greenlet 就是 cpython 上的一种轻量级线程（协程）的实现，因为 cpython 是用 c 实现的，所以这就要求 Greenlet 的实现要跟 c 那一套保持一致，要让协程里运行的代码感觉自己跑在一个真正的 c 堆栈上&lt;/p&gt;

&lt;p&gt;Greenlet 的做法是这样的：当一个 greenlet 运行时，它的堆栈区间数据将会完整地恢复放在 c 堆栈上，让它“原生态”地执行；若它被挂起，则有可能其部分或全部堆栈区间的数据会被拷贝到堆上保存；&lt;em&gt;这是因为所有同一个线程的 greenlets 共享同一个 c 堆栈的地址空间，它们的堆栈区间会有可能有交集重叠&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我们主要关注 &lt;code&gt;PyGreenlet&lt;/code&gt; 的这几个字段来讨论实现原理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack_stop&lt;/code&gt;: 该 greenlet 堆栈区间 &lt;em&gt;底&lt;/em&gt; 部地址（旧数据方向）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack_start&lt;/code&gt;: 该 greenlet 堆栈区间 &lt;em&gt;顶&lt;/em&gt; 部地址（新数据方向）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack_prev&lt;/code&gt;: &lt;em&gt;greenlet 链表&lt;/em&gt; 指针，见下节说明&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack_copy&lt;/code&gt;: 该 greenlet 堆栈区间在堆上的拷贝&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack_saved&lt;/code&gt;: 该 greenlet 堆栈区间在堆上的拷贝的长度&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;greenlet-链表&#34;&gt;greenlet 链表&lt;/h4&gt;

&lt;p&gt;如前所叙述，只有当前运行的 greenlet 是保证其堆栈区间完整地置于 c 堆栈上，其它挂起的 greenlets 的堆栈区间数据则是有可能部分或全部地拷贝到了堆上保存；&lt;/p&gt;

&lt;p&gt;那么任意时刻，c 堆栈就会由多个 greenlets 的部分或全部堆栈区间组成（这些区间有可能是紧贴着的，也可能中间有空隙，但必定不能重叠），Greenlet 库维护一个 greenlet 链表来表达 c 堆栈上这些区间的前后关系，该链表就是由 &lt;code&gt;stack_prev&lt;/code&gt; 串联而成的，例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;current.stack_prev -&amp;gt; intermediate.stack_prev -&amp;gt; ... -&amp;gt; main.stack_prev -&amp;gt; null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;链表头一定是当前运行的 greenlet，链表尾一定是 main/initial greenlet；这个链表只包含那些在 c 堆栈上有部分/全部堆栈区间的 greenlets，已经完全拷贝到堆上的那些 greenlets 不包含在这个链表中&lt;/p&gt;

&lt;h4 id=&#34;greenlet-堆栈区间&#34;&gt;greenlet 堆栈区间&lt;/h4&gt;

&lt;p&gt;说了那么久堆栈区间，一个 greenlet 是如何确定它的堆栈区间&lt;code&gt;[stack_stop, stack_start]&lt;/code&gt;的呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;stack_stop&lt;/code&gt; 是在一个 greenlet 首次开始执行时确定的（main greenlet 除外）：它取一个外层函数的本地变量地址，为什么可以这样呢？因为外层函数的本地变量处于 c 堆栈上且一定比内层函数（该 greenlet 的入口函数）更靠近 c 堆栈底部，由它作为 &lt;code&gt;stack_stop&lt;/code&gt; 肯定能包含该 greenlet 整个有效的堆栈地址区间；&lt;em&gt;这个地址在该 greenlet 的整个生命周期都不会改变&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;stack_start&lt;/code&gt; 是在一个 greenlet &lt;em&gt;每次&lt;/em&gt; 将要交出控制权的时候确定的，因为该 greenlet 正在运行，所以 &lt;code&gt;stack_start&lt;/code&gt; 就是当前 c 堆栈顶地址&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;大致切换过程&#34;&gt;大致切换过程&lt;/h4&gt;

&lt;p&gt;假设当前运行 greenlet 为 &lt;code&gt;current&lt;/code&gt; , 准备切换到 &lt;code&gt;target&lt;/code&gt; ，那么切换过程包括保存 greenlet 链表上各元素的堆栈区间以及恢复 &lt;code&gt;target&lt;/code&gt; 堆栈区间&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;保存：无论 &lt;code&gt;target&lt;/code&gt; 是第一次执行还是恢复执行，都是可以知道 &lt;code&gt;target.stack_stop&lt;/code&gt; 的（如前所叙述），也就知道 c 堆栈需要空出位置到哪里给它恢复了：遍历 greenlet 链表，将 &lt;code&gt;target.stack_stop&lt;/code&gt; 将要覆盖到的 greenlets 的堆栈区间分别保存到各自 greenlet 的 &lt;code&gt;stack_copy/stack_saved&lt;/code&gt; 中去&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;恢复：第一次执行不需要恢复，直接执行即可；恢复执行的话，则把拷贝到堆上的数据恢复到 c 堆栈上，然后把 &lt;code&gt;target&lt;/code&gt; 放入 greenlet 链表表头，设置 &lt;code&gt;target.stack_prev&lt;/code&gt; 维护 greenlet 链表&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;p&gt;来两张灵魂画风的图例&lt;/p&gt;

&lt;p&gt;切换前：&lt;/p&gt;

&lt;a href=&#34;./greenlets_before_switch.jpg&#34;&gt;&lt;img style=&#34;max-width: 100%; height: auto;&#34; src=&#34;./greenlets_before_switch.jpg&#34; alt=&#34;Greenlet 笔记 ./greenlets_before_switch.jpg&#34;&gt;&lt;/a&gt;


&lt;p&gt;切换后：&lt;/p&gt;

&lt;a href=&#34;./greenlets_after_switch.jpg&#34;&gt;&lt;img style=&#34;max-width: 100%; height: auto;&#34; src=&#34;./greenlets_after_switch.jpg&#34; alt=&#34;Greenlet 笔记 ./greenlets_after_switch.jpg&#34;&gt;&lt;/a&gt;


&lt;h4 id=&#34;注释&#34;&gt;注释&lt;/h4&gt;

&lt;p&gt;最后还是贴一下代码里的注释，这个是最权威的说明了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
A PyGreenlet is a range of C stack addresses that must be
saved and restored in such a way that the full range of the
stack contains valid data when we switch to it.

Stack layout for a greenlet:

               |     ^^^       |
               |  older data   |
               |               |
  stack_stop . |_______________|
        .      |               |
        .      | greenlet data |
        .      |   in stack    |
        .    * |_______________| . .  _____________  stack_copy + stack_saved
        .      |               |     |             |
        .      |     data      |     |greenlet data|
        .      |   unrelated   |     |    saved    |
        .      |      to       |     |   in heap   |
 stack_start . |     this      | . . |_____________| stack_copy
               |   greenlet    |
               |               |
               |  newer data   |
               |     vvv       |


Note that a greenlet&#39;s stack data is typically partly at its correct
place in the stack, and partly saved away in the heap, but always in
the above configuration: two blocks, the more recent one in the heap
and the older one still in the stack (either block may be empty).

Greenlets are chained: each points to the previous greenlet, which is
the one that owns the data currently in the C stack above my
stack_stop.  The currently running greenlet is the first element of
this chain.  The main (initial) greenlet is the last one.  Greenlets
whose stack is entirely in the heap can be skipped from the chain.

The chain is not related to execution order, but only to the order
in which bits of C stack happen to belong to greenlets at a particular
point in time.

The main greenlet doesn&#39;t have a stack_stop: it is responsible for the
complete rest of the C stack, and we don&#39;t know where it begins.  We
use (char*) -1, the largest possible address.

States:
  stack_stop == NULL &amp;amp;&amp;amp; stack_start == NULL:  did not start yet
  stack_stop != NULL &amp;amp;&amp;amp; stack_start == NULL:  already finished
  stack_stop != NULL &amp;amp;&amp;amp; stack_start != NULL:  active

The running greenlet&#39;s stack_start is undefined but not NULL.

*/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Vault Database Secret Backend 笔记</title>
      <link>//huangjunwen.github.io/post/2017/vault-database-secret-backend/</link>
      <pubDate>Sat, 10 Jun 2017 16:46:36 +0800</pubDate>
      
      <guid>//huangjunwen.github.io/post/2017/vault-database-secret-backend/</guid>
      <description>

&lt;p&gt;在当前版本（v0.7.2）这个 backend 还处于 beta 状态；这个 backend 应该是用来统一之前版本中各种数据库的 secret backend 的；使用前需要挂载 &lt;code&gt;vault mount database&lt;/code&gt;，这里用 MySQL 来演示它的主要工作流程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写入数据库配置，路径在 &lt;code&gt;database/config/$db_name&lt;/code&gt; ，主要参数有：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;db_name&lt;/code&gt; 这个配置的名字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plugin_name&lt;/code&gt; 指定用何种数据库 driver plugin（mysql/postgres 等）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connection_url&lt;/code&gt; 指定连接参数（注：这个连接参数是用来连数据库以创建用户的，需要有对应的权限）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allowed_roles&lt;/code&gt; 指定的是允许哪些角色使用此配置（角色是啥下一步就会说明）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全考虑：这个路径即使读权限也需要严格限制，因为它包含了相当高权限的数据库用户信息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;例子：&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ export db_name=&amp;quot;test&amp;quot;
$ export role_name=&amp;quot;test_reader&amp;quot;
$ export plugin_name=&amp;quot;mysql-legacy-database-plugin&amp;quot;             # mysql 有多个 plugin，它们的区别这是创建的数据库用户名最大长度不一样，因为不同版本用户名长度有变化
$ export connection_url=&amp;quot;root:password@tcp(127.0.0.1:3306)/&amp;quot;    # 不要忘了最后的 /

$ vault write database/config/$db_name \
&amp;gt;   plugin_name=$plugin_name \
&amp;gt;   connection_url=$connection_url \
&amp;gt;   allowed_roles=&amp;quot;$role_name&amp;quot; ...

The following warnings were returned from the Vault server:
* Read access to this endpoint should be controlled via ACLs as it will return the connection details as is, including passwords, if any.

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;创建角色，角色代表的是数据库用户的类型，路径在 &lt;code&gt;database/roles/$role_name&lt;/code&gt;，主要参数有：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;db_name&lt;/code&gt; 就是上一步创建的数据库配置名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;creation_statements&lt;/code&gt;/&lt;code&gt;revocation_statements/...&lt;/code&gt; 等是在创建具体用户／注销用户等时执行的语句，这些语句中可以添加如 &lt;code&gt;{{name}}&lt;/code&gt;/&lt;code&gt;{{password}}&lt;/code&gt; 等这些占位符，待生成真正用户时，这里会特换成动态生成的值，这些也就是这个 backend 要自动管理的秘密了，具体支持哪些占位符需要参阅各个 driver 的文档&lt;/li&gt;
&lt;li&gt;例子：&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ vault write database/roles/$role_name \
&amp;gt;   db_name=$db_name \
&amp;gt;   creation_statements=&amp;quot;CREATE USER &#39;{{name}}&#39;@&#39;%&#39; IDENTIFIED BY &#39;{{password}}&#39;;GRANT SELECT ON test.* TO &#39;{{name}}&#39;&amp;quot; \
&amp;gt;   default_ttl=15m

Success! Data written to: database/roles/test_reader
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里创建了一个角色，用这个角色创建的用户对 &lt;code&gt;test&lt;/code&gt; 数据库有读权限，且用户名／密码的默认有效时间是 15 分钟，超时且没有续租的话，Vault 就会删除掉这个用户。（注意由于 MySQL plugin 默认有 &lt;code&gt;revocation_statements&lt;/code&gt; 可以不用提供，这些细节要看相关 plugin 的说明）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建用户，路径在 &lt;code&gt;database/creds/$role_name&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ vault read database/creds/$role_name

Key             Value
---             -----
lease_id        database/creds/test_reader/8e735c82-2eb7-53cf-9cc6-d9c9dc16dd96
lease_duration  15m0s
lease_renewable true
password        96d17f10-9c67-8d44-26d1-c77dcd3e6ec1
username        v-root-01fc63a1-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次读取这个路径时，Vault 就会调用 &lt;code&gt;creation_statements&lt;/code&gt; 创建一个新用户，返回动态生成的用户名密码，并对这个秘密关联租约（由 &lt;code&gt;lease_id&lt;/code&gt; 标识），这个租约默认 15 分钟内有效，可以续租&lt;/p&gt;

&lt;p&gt;由此，我们就可以把一个 MySQL root 权限的用户保存在 Vault 中，并由它来动态产生受限的数据库用户，这些受限的数据库用户可以存在时间很短，使用它的服务可以定时续租，一旦服务停止，这个用户很快就会被删除掉&lt;/p&gt;

&lt;h4 id=&#34;一些细节&#34;&gt;一些细节&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;database/config/$db_name&lt;/code&gt;: 数据库配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;database/roles/$role_name&lt;/code&gt;: 角色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;database/creds/test_reader/8e735c82-2eb7-53cf-9cc6-d9c9dc16dd96&lt;/code&gt;: 具体用户秘密租约&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这三部分信息是独立，删除修改其中一个貌似并不会影响其它，例如删除数据库配置，角色还是在的，只是创建具体用户的时候会失败，说无法找到相应的数据库配置；又如删除了角色，则具体用户在被吊销的时候也会报错，导致数据库里面还残留没有被删除的用户。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vault 笔记</title>
      <link>//huangjunwen.github.io/post/2017/vault/</link>
      <pubDate>Wed, 07 Jun 2017 08:14:18 +0800</pubDate>
      
      <guid>//huangjunwen.github.io/post/2017/vault/</guid>
      <description>

&lt;p&gt;之前一篇 &lt;a href=&#34;//huangjunwen.github.io/post/2017/shamir-secret-sharding/&#34;&gt;博文&lt;/a&gt; 介绍了 &lt;a href=&#34;https://www.vaultproject.io/&#34;&gt;Hashicorp Vault&lt;/a&gt; 的解封／密封算法。这篇打算记录一下这个软件的其它方面。当前最新版本为 v0.7.2 。&lt;/p&gt;

&lt;p&gt;Vault 是一个相当复杂的系统，总括而言，它是一个集中管理各类敏感信息（如密码／Key／证书等等）的软件（服务）。Vault 采用类似 Unix &lt;a href=&#34;https://en.wikipedia.org/wiki/Everything_is_a_file&#34;&gt;“一切皆文件”&lt;/a&gt; 的方式组织及暴露各类信息：所有操作都是对某个路径的 read／write （实际上是对某个 HTTP 路径 POST／GET／LIST／DELETE 等） ，例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/sys&lt;/code&gt; 目录下是各种配置路径，此目录不可被卸载，其下路径各有用途，如 &lt;code&gt;/sys/seal&lt;/code&gt; 和 &lt;code&gt;/sys/unseal&lt;/code&gt; 这两个路径是用来密封／解封 vault 的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/secret&lt;/code&gt; 目录下挂载的是 &lt;a href=&#34;https://www.vaultproject.io/docs/secrets/generic/index.html&#34;&gt;Generic Secret Backend&lt;/a&gt;，用于存放一般用途的敏感信息，其下路径组织结构由用户自行决定，我们平时实际使用访问最多的应该也是这个。&lt;/li&gt;
&lt;li&gt;&amp;hellip; 更多目录路径说明可参看 &lt;a href=&#34;https://www.vaultproject.io/api/index.html&#34;&gt;API 文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;读取／写入的数据一般都是 JSON 格式。&lt;/p&gt;

&lt;h2 id=&#34;backends&#34;&gt;Backends&lt;/h2&gt;

&lt;p&gt;Vault 主要由几类 backends 合作组成：&lt;/p&gt;

&lt;p&gt;Auth -&amp;gt; Secret -&amp;gt; Storage(Physical) -&amp;gt; Audit&lt;/p&gt;

&lt;p&gt;认证 -&amp;gt; 实际操作 -&amp;gt; 落盘储存 -&amp;gt; 日志&lt;/p&gt;

&lt;h3 id=&#34;auth-entication-backend&#34;&gt;Auth(entication) Backend&lt;/h3&gt;

&lt;p&gt;Auth Backend 完成的是认证工作：访问者是谁。有多种可通过挂载添加，默认情况下它们会挂载在 &lt;code&gt;auth/&amp;lt;type&amp;gt;&lt;/code&gt; 下，以下是其中一些认证方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/docs/auth/token.html&#34;&gt;token&lt;/a&gt; 这个 Backend 是 Vault 的核心认证方式，默认挂载，不可卸载，非常重要，下一小节详细描述&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/docs/auth/userpass.html&#34;&gt;userpass&lt;/a&gt; 用户名密码认证&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/docs/auth/github.html&#34;&gt;github&lt;/a&gt; 用 Github 的认证服务&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/docs/auth/cert.html&#34;&gt;cert&lt;/a&gt; 用 tls 证书认证&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/docs/auth/approle.html&#34;&gt;approle&lt;/a&gt; &lt;em&gt;TODO&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;token-令牌&#34;&gt;Token （令牌）&lt;/h4&gt;

&lt;p&gt;对外部而言，顾名思义，有了令牌就能通行，它是访问者身份的象征；实际上，Vault 对外 API 中绝大部分（除了像 seal／unseal 这种）都需要令牌才能访问：访问的 HTTP 请求头部需要加上 &lt;code&gt;X-Vault-Token: xxxxxx&lt;/code&gt; （命令行其实也是调用 HTTP API 的，Token 保存在 &lt;code&gt;~/.vault_token&lt;/code&gt; 里以供其使用）&lt;/p&gt;

&lt;p&gt;对内部而言，Token 是 Vault 里多个组件间的结合点，关联对应许多信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;树状层次：除了 root tokens 和 orphan tokens 外都有父 token，故所有 tokens 形成一个树（森林）状层次结构，当父 token 被吊销时，其所有子孙 tokens 都会同时被吊销&lt;/li&gt;
&lt;li&gt;限时：token 是有使用时限的（TTL），超时时会被吊销，可以续租延长时限的（但不超过某个最大值），也可以是周期性的 token（可通过周期性地续租无限延长使用时间）&lt;/li&gt;
&lt;li&gt;限次：token 可以限制使用次数，默认是不限制，超过使用次数后会被吊销，这个可以用作实现 one-time-password&lt;/li&gt;
&lt;li&gt;访问控制策略（Access Control Policies）：这是最关键的，每个 token 都关联一个访问控制策略列表（如 &lt;code&gt;[&amp;quot;default&amp;quot;, &amp;quot;dev&amp;quot;]&lt;/code&gt;），访问控制策略就是 Vault 里头的权限控制机制，例如 &lt;code&gt;default&lt;/code&gt; 策略是这样的：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ vault policies default  # 查看名为 default 的控制策略

# Allow tokens to look up their own properties
path &amp;quot;auth/token/lookup-self&amp;quot; {
    capabilities = [&amp;quot;read&amp;quot;]
}

# Allow tokens to renew themselves
path &amp;quot;auth/token/renew-self&amp;quot; {
    capabilities = [&amp;quot;update&amp;quot;]
}

# Allow tokens to revoke themselves
path &amp;quot;auth/token/revoke-self&amp;quot; {
    capabilities = [&amp;quot;update&amp;quot;]
}

# Allow a token to look up its own capabilities on a path
path &amp;quot;sys/capabilities-self&amp;quot; {
    capabilities = [&amp;quot;update&amp;quot;]
}

...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;归功于“一切皆文件”的统一设计，能干什么不能干什么（create/read/update/delete/list/sudo/deny）都统一到一组路径上的读写权限。详情可参看 &lt;a href=&#34;https://www.vaultproject.io/docs/concepts/policies.html&#34;&gt;https://www.vaultproject.io/docs/concepts/policies.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;整个流程应该是这样子的：用户（人／机器）携带着令牌调用某个 API，Vault 检查这个令牌是否已被吊销，是否超过使用限制，访问的操作／路径是否被允许，如果都通过了这些检查，才会实际执行操作。&lt;/p&gt;

&lt;p&gt;那么好了，令牌本身又是从哪里来的呢？方法有几个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;root tokens 可以在 Vault 初始化的时候获得，也可以在之后通过 &lt;code&gt;vault generate-root&lt;/code&gt; 命令或 &lt;a href=&#34;https://www.vaultproject.io/api/system/generate-root.html&#34;&gt;/sys/generate-root&lt;/a&gt; API 创建新的（需要 unseal key），root token 是 token 中的 superuser，啥都可以做，且一般没有超时时间&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;vault token-create&lt;/code&gt; 命令或 &lt;a href=&#34;https://godoc.org/github.com/hashicorp/vault/api#TokenAuth.Create&#34;&gt;/auth/token/create&lt;/a&gt; API 为当前 token 手动创建子 token，子 token 的访问控制策略只能是当前 token 的子集&lt;/li&gt;
&lt;li&gt;其它 auth backends 完成对认证后，其实返回的也是 token（所以从这个角度看，Vault 其实就只有 token 一种认证方式），至于返回的是什么样的 token，则决定于这个 auth backend 的配置是怎么样的；例如 Github 可以关联某个 team 或者某个 user 到指定访问控制策略，当这个 team 的成员或这个用户用 Github 的 Personal Access Token 完成认证后，就返回关联此策略的一个 token&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于 token 的更详细文档可以参看这里： &lt;a href=&#34;https://www.vaultproject.io/docs/concepts/tokens.html&#34;&gt;https://www.vaultproject.io/docs/concepts/tokens.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;secret-backend&#34;&gt;Secret Backend&lt;/h3&gt;

&lt;p&gt;用来存放（生成）秘密的地方；不同的 backend 类似于不同的虚拟文件系统（tmpfs，udev 等），可以挂载到不同的目录，读写到不同的 backend 下会有各自不同的作用，如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/api/secret/generic/index.html&#34;&gt;generic&lt;/a&gt; 前文也提及过，一般用途的 backend&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/docs/secrets/databases/index.html&#34;&gt;database&lt;/a&gt; 用来管理数据库连接信息，具体参看另一篇&lt;a href=&#34;../vault-database-secret-backend/&#34;&gt;博文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/api/secret/pki/index.html&#34;&gt;pki&lt;/a&gt; 用来管理（生成） X.509 证书 &lt;em&gt;TODO&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/api/secret/cubbyhole/index.html&#34;&gt;cubbyhole&lt;/a&gt; 类似于 generic secret backend 可以存放任意秘密，但不同之处在于它是 token scoped 的

&lt;ul&gt;
&lt;li&gt;解释：举个类比，很多 Unix 系统有一个文件夹 &lt;code&gt;/dev/fd&lt;/code&gt;，像一个私有的空间，每一个进程访问都只能看到本进程的打开了的文件描述符；cubbyhole 类似于此，每一个 token 能访问到的都是一个只有自己能访问到的私有空间，当这个 token 销毁的时候，存储在这里面的所有秘密也一并被销毁&lt;/li&gt;
&lt;li&gt;用处：例如我们从 Vault 中读取了一些秘密，这个秘密可能会通过很多中间环节才能送到最终的使用者手上，中间环节越多，泄漏的可能性就越大（例如不小心被 log 下来了等），那么可以通过创建一个寿命非常短（例如几秒）且只能用一次的 token，把密码放到此 token 的 cubbyhole 里，中间环节传输的则是这个
token，即使泄漏了，由于其限时限次，秘密泄漏的可能性就大大降低了，同时如果泄漏了，日志里面必定会有所记录（偷取访问一次／正常访问一次，第二次失败），这是所谓 &lt;a href=&#34;https://www.vaultproject.io/docs/secrets/cubbyhole/index.html#response-wrapping&#34;&gt;Response Wrapping&lt;/a&gt;；其实这不就有点像 OAuth2 的流程一样，拿一个很短命的 code 去换取 Access Token （秘密）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hashicorp.com/blog/cubbyhole-authentication-principles&#34;&gt;https://www.hashicorp.com/blog/cubbyhole-authentication-principles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/docs/secrets/cubbyhole/index.html&#34;&gt;https://www.vaultproject.io/docs/secrets/cubbyhole/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;storage-physical-backend&#34;&gt;Storage (Physical) Backend&lt;/h3&gt;

&lt;p&gt;数据真正落盘的地方（注：到达 Storage Backend 时，数据都已经处于加密状态了，安全并不依赖于 Storage backend，实际上它是 untrusted 的，下面代码里有提到），需要在服务启动时在&lt;a href=&#34;https://www.vaultproject.io/docs/configuration/storage/index.html&#34;&gt;配置&lt;/a&gt;里面指定；这类 backend 同样有很多种，例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/docs/configuration/storage/in-memory.html&#34;&gt;inmem&lt;/a&gt; 存放在内存中（dev 模式下即是使用 inmen backend 的，一旦重启，数据就丢失了）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/docs/configuration/storage/filesystem.html&#34;&gt;file&lt;/a&gt; 直接存放在本地文件里&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/docs/configuration/storage/mysql.html&#34;&gt;mysql&lt;/a&gt; 存放在 MySQL 数据库里&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vaultproject.io/docs/configuration/storage/consul.html&#34;&gt;consul&lt;/a&gt;/&lt;a href=&#34;https://www.vaultproject.io/docs/configuration/storage/etcd.html&#34;&gt;etcd&lt;/a&gt; 存放在 Key-Value 集群中（高可用）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如使用 mysql backend，vault init 后可以看到数据库里头实际上创建了一个表而已，此表就两个字段 &lt;code&gt;vault_key&lt;/code&gt; 和 &lt;code&gt;vault_value&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vault_key&lt;/code&gt; 是形如 &lt;code&gt;sys/policy/default&lt;/code&gt; &lt;code&gt;logical/12345678-1234-1234-1234-123456790abc/ca&lt;/code&gt; 等等这类内部路径名称。注意：路径是没有加密的，所以 Vault 的文档某个地方（我忘了在哪里了）指出不要把敏感信息暴露在路径上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vault_value&lt;/code&gt; 大部分是加密后的二进制数据，也有些是明文的，如 &lt;code&gt;core/seal-config&lt;/code&gt; 记录密封算法跟参数：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;type&amp;quot;:&amp;quot;shamir&amp;quot;,&amp;quot;secret_shares&amp;quot;:5,&amp;quot;secret_threshold&amp;quot;:3,&amp;quot;pgp_keys&amp;quot;:null,&amp;quot;nonce&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;backup&amp;quot;:false,&amp;quot;stored_shares&amp;quot;:0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这部分信息是在没解封前就要用到的，所以只能用明文；我尝试了下改了参数，例如把 &lt;code&gt;secret_threshold&lt;/code&gt; 改成 1 看看能不能只要一个 key 就能解封，结果&amp;hellip;当然是不能啦 :-)&lt;/p&gt;

&lt;p&gt;看了一下相关的代码，发现其实这部分很好理解，实际上只要提供以下这个 &lt;a href=&#34;https://godoc.org/github.com/hashicorp/vault/physical#Backend&#34;&gt;interface&lt;/a&gt; 就能用作 storage backend 了（其实就是一个可以枚举的 Key-Value store 即可）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Backend is the interface required for a physical
// backend. A physical backend is used to durably store
// data outside of Vault. As such, it is completely untrusted,
// and is only accessed via a security barrier. The backends
// must represent keys in a hierarchical manner. All methods
// are expected to be thread safe.
type Backend interface {
	// Put is used to insert or update an entry
	Put(entry *Entry) error

	// Get is used to fetch an entry
	Get(key string) (*Entry, error)

	// Delete is used to permanently delete an entry
	Delete(key string) error

	// List is used ot list all the keys under a given
	// prefix, up to the next prefix.
	List(prefix string) ([]string, error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里提到的 &amp;ldquo;As such, it is completely untrusted, &amp;hellip;&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;audit-backend&#34;&gt;Audit Backend&lt;/h3&gt;

&lt;p&gt;记日志的，对于敏感信息，日志会进行 HMAC-SHA256 哈希，这样做可以避免暴露明文但仍然能进行对照检查；另外如果启动了至少一个 audit backends 的话，对 Vault 的每一个请求都会&lt;strong&gt;阻塞&lt;/strong&gt;直到其中一个日志完成记录，这样就能保证没有任何的操作不被记录下来&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>微服务中的认证 (authentication) 问题</title>
      <link>//huangjunwen.github.io/post/2017/authentication_in_microservice/</link>
      <pubDate>Sun, 14 May 2017 19:14:51 +0800</pubDate>
      
      <guid>//huangjunwen.github.io/post/2017/authentication_in_microservice/</guid>
      <description>&lt;p&gt;这帖子有意思 &lt;a href=&#34;https://news.ycombinator.com/item?id=11929267&#34;&gt;JSON Web token vs. Session&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;“单纯”的 JWT，其实跟 client side session 没啥区别，它的优缺点都一样：&lt;/p&gt;

&lt;p&gt;Pros：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务端不需要储存 session 数据&lt;/li&gt;
&lt;li&gt;stateless&lt;/li&gt;
&lt;li&gt;因为不用访问任何储存服务，验证过程超快速&lt;/li&gt;
&lt;li&gt;易于 scale up&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;session 很难被主动清除（除非过期）&lt;/li&gt;
&lt;li&gt;所有信息都暴露在外（或者有暴露的危险）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最终我觉得一个比较好的办法是结合这两者：对外使用 session，提供一个 opaque 的 token (reference token) 作为 session id，在网关中做翻译过程，将这个 reference token 转换成真实的 jwt，然后在网关内的服务就都使用 jwt。&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&#34;https://www.slideshare.net/opencredo/authentication-in-microservice-systems-david-borsos&#34;&gt;muCon 2016: Authentication in Microservice Systems By David Borsos&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Shamir&#39;s Secret Sharding</title>
      <link>//huangjunwen.github.io/post/2017/shamir-secret-sharding/</link>
      <pubDate>Sun, 23 Apr 2017 09:27:43 +0800</pubDate>
      
      <guid>//huangjunwen.github.io/post/2017/shamir-secret-sharding/</guid>
      <description>

&lt;script type=&#34;text/javascript&#34; async src=&#34;//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&#34;&gt;&lt;/script&gt;


&lt;p&gt;&lt;a href=&#34;https://www.hashicorp.com&#34;&gt;Hashicorp&lt;/a&gt; 这家公司的产品都很有意思，其中 &lt;a href=&#34;https://www.vaultproject.io/&#34;&gt;Vault&lt;/a&gt; 是一个用来集中管理敏感信息（密码，各种 token，证书，key 等等）的工具。&lt;/p&gt;

&lt;p&gt;Vault server 运行起来之后有两种状态：&lt;em&gt;seal/unseal（密封／解封）&lt;/em&gt;  ，这是因为：&lt;/p&gt;

&lt;p&gt;Vault 的数据是加密储存在磁盘上的：由  &lt;strong&gt;encryption key&lt;/strong&gt;  加密，这个  encryption key  是由  &lt;strong&gt;master key&lt;/strong&gt;  加密储存在磁盘上，而  master key  是不存放在磁盘上。所以当 Vault server 刚启动时，由于  master key  未知，故  encryption key  以及实际数据都是无法被解密访问的，这种状态就称之为&lt;em&gt;seal（密封）&lt;/em&gt; ，&lt;em&gt;unseal（解封）&lt;/em&gt; 就是重建  master key  的过程。&lt;/p&gt;

&lt;p&gt;由于 master key 太重要了，Vault 使用所谓的 &lt;a href=&#34;https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing&#34;&gt;Shamir&amp;rsquo;s Secret Sharing&lt;/a&gt; 算法把这个 master key 切分并分发给 n 个人，只有当这 n 个人里的最少 k 个人授权提供他们持有的部分，vault 才能重构出这个 master key，这个算法挺有趣，所以写篇博客记录下来：&lt;/p&gt;

&lt;h3 id=&#34;目标&#34;&gt;目标&lt;/h3&gt;

&lt;p&gt;密码 &lt;span&gt;\(S\)&lt;/span&gt;
 需要切分成 &lt;span&gt;\(n\)&lt;/span&gt;
 份： &lt;span&gt;\(S_1, S_2, ... S_n\)&lt;/span&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;大于等于 &lt;span&gt;\(k\)&lt;/span&gt;
 个任意 &lt;span&gt;\(S_i\)&lt;/span&gt;
 就能算出 &lt;span&gt;\(S\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;少于等于 &lt;span&gt;\(k-1\)&lt;/span&gt;
 个任意 &lt;span&gt;\(S_i\)&lt;/span&gt;
 无法算出 &lt;span&gt;\(S\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;这个算法的思路是这样的：在平面几何中，2 个点就能唯一决定一条直线，3 个点就能唯一决定一条抛物线，4 个点能唯一决定一条三次曲线。。。反之，1 个点决定不了唯一一条直线，2 个点或更少决定不了唯一一条抛物线。。。&lt;/p&gt;

&lt;p&gt;对于一条 &lt;span&gt;\(k-1\)&lt;/span&gt;
 次曲线&lt;/p&gt;

&lt;span&gt;$$f(x) = a_0 &amp;#43; a_{1}x &amp;#43; a_{2}x^{2} &amp;#43; ... &amp;#43; a_{k-1}x^{k-1} $$&lt;/span&gt;


&lt;p&gt;只要 &lt;span&gt;\(k\)&lt;/span&gt;
 个点就能唯一决定，而少于 &lt;span&gt;\(k\)&lt;/span&gt;
 个点，则有无限条 &lt;span&gt;\(k-1\)&lt;/span&gt;
 次曲线穿过这些点。&lt;/p&gt;

&lt;p&gt;所以算法是这样的，令 &lt;span&gt;\(a_0 = S\)&lt;/span&gt;
，再随机选取 &lt;span&gt;\(a_{1}, a_{2}, ... , a_{k-1}\)&lt;/span&gt;
，这样就构造出一条 &lt;span&gt;\(k-1\)&lt;/span&gt;
 次曲线，在曲线上随机选取 &lt;span&gt;\(n\)&lt;/span&gt;
 个点，这些点（的坐标值）就是分发给各人的密码 &lt;span&gt;\(S_i\)&lt;/span&gt;
 了。 只要超过 &lt;span&gt;\(k\)&lt;/span&gt;
 个人提供他们的密码（点），就能重构曲线，也就能获得 &lt;span&gt;\(S = a_0 = f(0)\)&lt;/span&gt;
 了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Public Key Cryptography 笔记（2.1）-- ASN.1</title>
      <link>//huangjunwen.github.io/post/2017/public-key-cryptography-notes-2-1-asn1/</link>
      <pubDate>Wed, 01 Feb 2017 09:19:40 +0800</pubDate>
      
      <guid>//huangjunwen.github.io/post/2017/public-key-cryptography-notes-2-1-asn1/</guid>
      <description>

&lt;script type=&#34;text/javascript&#34; async src=&#34;//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&#34;&gt;&lt;/script&gt;


&lt;h4 id=&#34;记法和编码&#34;&gt;记法和编码&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One&#34;&gt;ASN.1（Abstract syntax notation one）&lt;/a&gt; 是一个对数据（类型／值）的记法和编码的&lt;del&gt;祖父级&lt;/del&gt;标准；制定几十年而依然健在且广泛使用。&lt;/p&gt;

&lt;p&gt;对比一下 &lt;a href=&#34;https://en.wikipedia.org/wiki/JSON&#34;&gt;JSON（Javascript Object Notation）&lt;/a&gt;，JSON 中的记法和编码是等价的，即它的记法就是编码。&lt;/p&gt;

&lt;p&gt;而 ASN.1 中记法和编码是不一样的，记法主要是为人类服务，用于描述，是抽象且实现无关的，例如（摘自&lt;a href=&#34;https://www.obj-sys.com/asn1tutorial/node11.html#asn1_struct&#34;&gt;这里&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AirlineFlight  ::=  SEQUENCE {
    airline   IA5String,
    flight    NumericString,
    seats     SEQUENCE {
                  maximum   INTEGER,
                  occupied  INTEGER,
                  vacant    INTEGER
    },
    airport   SEQUENCE {
                  origin             IA5String,
                  stop1       [0]    IA5String  OPTIONAL,
                  stop2       [1]    IA5String  OPTIONAL,
                  destination        IA5String
              },
    crewsize ENUMERATED {
                 six    (6),
                 eight  (8),
                 ten    (10)
             },
    cancel   BOOLEAN    DEFAULT FALSE
}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而编码则是具体实现序列化以及反序列化的操作，ASN.1 有很多种编码方式，例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Basic Encoding Rule (BER)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Canonical Encoding Rules (CER)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distinguished Encoding Rules (DER)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;XML Encoding Rules (XER)&lt;/li&gt;
&lt;li&gt;Packed Encoding Rules (PER)&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这篇笔记主要记录 ASN.1 记法以及 BER／DER 这两种常用编码。&lt;/p&gt;

&lt;h4 id=&#34;类型-tag&#34;&gt;类型／Tag&lt;/h4&gt;

&lt;p&gt;ASN.1 中数据是有类型的，不同类型的数据有不同的值域，类型按特点用途可以划分成以下四种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;simple type&lt;/strong&gt;，“原子”类型，例如 BOOLEAN，INTEGER 等本身不可分解的基本类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;structured type&lt;/strong&gt;，由其它类型组装而成的类型，包括 SEQUENCE，SEQUENCE OF，SET，SET OF，类似于一些计算机语言中的 struct, array, set 等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tagged type&lt;/strong&gt;，类似于类型别名，用于包装一个已有的类型；这在一些有歧义的场合下可作区分用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;other type&lt;/strong&gt;，包括 CHOICE 和 ANY&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每一种类型（除 CHOICE 和 ANY 外）都可以由一个 &lt;code&gt;tag := (class, tag number)&lt;/code&gt; 来唯一标识（所以以下 &amp;ldquo;tag&amp;rdquo; 和 “类型” 这两个词基本等价混用），其中类别 &lt;code&gt;class&lt;/code&gt;，相当于命名空间；非负整数 &lt;code&gt;tag number&lt;/code&gt;，相当于在此命名空间中的类型编号；有四种类别：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;universal&lt;/strong&gt;，内建类别，这一类别的 tag 对所有应用来说都表示相同的类型，貌似大部分（还是全部？）的 simple/structured 类型都定义在这个类别中，由 X.208 所定义，以下是一些例子：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;End-of-Content&lt;/code&gt;: tag number 为 0，这是个特殊的类型，用于标识不确定长度数据的结束，下面再详叙&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOLEAN&lt;/code&gt;: tag number 为 1，布尔类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INTEGER&lt;/code&gt;: tag number 为 2，任意精度的整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BIT STRING&lt;/code&gt;: tag number 为 3，任意长度的比特串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OCTET STRING&lt;/code&gt;: tag number 为 4，任意长度的字节串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NULL&lt;/code&gt;: tag number 为 5&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OBJECT IDENTIFIER(OID)&lt;/code&gt;: tag number 为 6，&lt;a href=&#34;https://en.wikipedia.org/wiki/Object_identifier&#34;&gt;对象标识符&lt;/a&gt;，用于为各种“东西”／“概念”起一个唯一的标识符，由机构 ITU 和 ISO/IEC 标准化；其具体形式类似于域名的多级树状结构，子级对象从属于父对象，只是每一级由一个整数表示，例如：

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oid-info.com/get/1&#34;&gt;1&lt;/a&gt; 表示的是 iso&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oid-info.com/get/1.2&#34;&gt;1.2&lt;/a&gt; member-body，ISO member bodies&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oid-info.com/get/1.2.840&#34;&gt;1.2.840&lt;/a&gt; us，美国&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oid-info.com/get/1.2.840.113549&#34;&gt;1.2.840.113549&lt;/a&gt; rsadsi，即 RSA Security LLC 公司&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oid-info.com/get/1.2.840.113549.1&#34;&gt;1.2.840.113549.1&lt;/a&gt; pkcs，即 RSA 公司制定的 Public-Key Cryptography Standards (PKCS) 系列标准&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oid-info.com/get/1.2.840.113549.1.1&#34;&gt;1.2.840.113549.1.1&lt;/a&gt; pkcs-1，即 PKCS#1 标准&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oid-info.com/get/1.2.840.113549.1.1.13&#34;&gt;1.2.840.113549.1.1.13&lt;/a&gt; sha512WithRSAEncryption&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UTF8 STRING&lt;/code&gt;: tag number 为 12&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SEQUENCE 和 SEQUENCE OF&lt;/code&gt;: tag number 为 16，有序的结构体和列表（不明白为什么不区分两个 tag 呢？）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SET 和 SET OF&lt;/code&gt;: tag number 为 17，无序的结构体和列表（继续不明白为什么不区分两个 tag）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PrintableString&lt;/code&gt;: tag number 为 19（有了 &lt;code&gt;OCTET STRING&lt;/code&gt; 为什么还要区分这个呢？）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IA5String&lt;/code&gt;: tag number 为 22，大致等价于 ASCII 字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UTCTIME&lt;/code&gt;: tag number 为 23&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;application&lt;/strong&gt;，这一类别的 tag 的意义由某应用内定义，对不同的应用来说，即使相同的 tag number 对应的是不同的含义&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;private&lt;/strong&gt;，这一类别的 tag 的意义由某企业或组织定义&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;context-specific&lt;/strong&gt;，这一类别的 tag 主要用于在特定的上下文中里解决歧义问题，例如某个 SEQUENCE 类型里面包含了两个相邻的可缺省的 INTEGER 字段，假如编码过后只传来一个整数（另外一个取缺省值），那究竟这个值是属于哪个字段呢？这时候就需要给这两个字段封装成新的 tagged 类型加以区分&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ber-basic-encoding-rules-简介&#34;&gt;BER (Basic Encoding Rules) 简介&lt;/h4&gt;

&lt;p&gt;BER 对数据的编码一般由以下三（或四）个部件按顺序构成，常简称 &lt;strong&gt;TLV&lt;/strong&gt; (Type-Length-Value)：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Identifier octets&lt;/strong&gt;（T）：用于编码这个数据的类型／tag&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Length octets&lt;/strong&gt;（L）：用于编码数据的长度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Contents octets&lt;/strong&gt;（V）：实际数据的编码，长度可以为 0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;End-of-contents octets&lt;/strong&gt;（optional）：有些数据在编码时还不知道具体长度，例如流数据，这个时候需要有一个结束标志&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Identifier octets&lt;/strong&gt; 对类型的编码使用 1+ 个字节，第一个字节编码包括 tag class，primitive 标识位（&lt;strong&gt;注意：这个标识位是用来标识数据编码时的方法，跟上边所说的 simple／structured／&amp;hellip; 类型分类没有太大关系&lt;/strong&gt;），以及 tag number ：小于等于 30 的 tag number 直接编码在第一个字节；对于更大的 tag number，第一字节写死 31，并用后续字节的低 7 位编码实际 tag number，后续字节的最高位设为 1，除了最后一个设为 0 用以标识结束；整理图示如下：&lt;/p&gt;

&lt;a href=&#34;./asn1-ber-identifier-octets.png&#34;&gt;&lt;img style=&#34;max-width: 100%; height: auto;&#34; src=&#34;./asn1-ber-identifier-octets.png&#34; alt=&#34;Public Key Cryptography 笔记（2.1）-- ASN.1 ./asn1-ber-identifier-octets.png&#34;&gt;&lt;/a&gt;


&lt;p&gt;&lt;strong&gt;Length octets&lt;/strong&gt; 对实际数据的长度进行编码，有三种形式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;确定长度短形式，可编码 &lt;span&gt;\([0, 127]\)&lt;/span&gt;
，仅需要一个字节编码&lt;/li&gt;
&lt;li&gt;确定长度长形式，可编码 &lt;span&gt;\([0, 2^{8\times126}-1]\)&lt;/span&gt;
，需要两个到127个字节编码&lt;/li&gt;
&lt;li&gt;不确定长度形式，用于在编码阶段无法确定长度的数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体方法整理如下图：&lt;/p&gt;

&lt;a href=&#34;./asn1-ber-length-octets.png&#34;&gt;&lt;img style=&#34;max-width: 100%; height: auto;&#34; src=&#34;./asn1-ber-length-octets.png&#34; alt=&#34;Public Key Cryptography 笔记（2.1）-- ASN.1 ./asn1-ber-length-octets.png&#34;&gt;&lt;/a&gt;


&lt;p&gt;&lt;strong&gt;Content octets&lt;/strong&gt; 不同类型的数据编码方式各异，见下面分述&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;End-of-Content octets&lt;/strong&gt; 对于不确定长度的复合类型数据，在最后需要有一个结束标识 &lt;code&gt;00 00&lt;/code&gt; （两个值为 0 的字节），这其实就是一个 &lt;code&gt;End-of-Content&lt;/code&gt; 类型的数据的 BER 编码：因为它是 universal 中 tag number 为 0 的，且它没有数据，所以 length-octets 为 0&lt;/p&gt;

&lt;h4 id=&#34;der-distinguished-encoding-rules-简介&#34;&gt;DER (Distinguished Encoding Rules) 简介&lt;/h4&gt;

&lt;p&gt;DER 其实是 BER 的一个严格子集（即任意 DER 编码的数据都是合法的 BER 编码，但反之则未必），它要求对数据只能有唯一一种编码方式，这样做的原因是例如在创建数字签名的时候，同一份数据假如用 BER 里不同的编码方式（例如长度可以用长模式或短模式），那么会产生不一样的签名结果。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/X.690#DER_encoding&#34;&gt;wiki&lt;/a&gt; 上列出一些最显著的一些限制规则，如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只能使用确定形式来编码长度，且必须使用最短的编码形式（如长度若小于等于 127，则必须使用短形式）&lt;/li&gt;
&lt;li&gt;各种 string 类型必须使用 primitive 的编码方式&lt;/li&gt;
&lt;li&gt;SET 类型（无序结构体）里的字段需要按照 tag 值的大小排序进行编码（排序了就唯一了）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;一些类型的记法及编码方式&#34;&gt;一些类型的记法及编码方式&lt;/h4&gt;

&lt;p&gt;以下基本翻译自：&lt;a href=&#34;http://luca.ntop.org/Teaching/Appunti/asn1.html&#34;&gt;http://luca.ntop.org/Teaching/Appunti/asn1.html&lt;/a&gt; 第五节&lt;/p&gt;

&lt;h5 id=&#34;integer&#34;&gt;INTEGER&lt;/h5&gt;

&lt;p&gt;tag number 为 2，整数类型可以是正／负的任意精度整数。 记法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INTEGER [ &#39;{&#39; identifier1(value1) ... identifiern(valuen) &#39;}&#39; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;identifier1&lt;/code&gt; &amp;hellip; &lt;code&gt;identifiern&lt;/code&gt; 如果有的话，这些标识符将绑定其对应的整数值，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Version ::= INTEGER { v1988(0) }

...

Certificate ::= ...
  version Version DEFAULT v1988,
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是 X.509 里头的版本类型，定义了 &lt;code&gt;v1988&lt;/code&gt; 这个标识符，其值为 0；证书类型里头的版本默认即为这个值。&lt;/p&gt;

&lt;p&gt;BER 编码是 primitive 方式，使用&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8&#34;&gt;补码&lt;/a&gt; 来编码此整数，如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0: &lt;code&gt;02 01 00&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;127: &lt;code&gt;02 01 7f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;128: &lt;code&gt;02 02 00 80&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;-128: &lt;code&gt;02 01 80&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;bit-string&#34;&gt;BIT STRING&lt;/h5&gt;

&lt;p&gt;tag number 为 3，比特串可以表示任意长度（包括0）的 0 和 1。记法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BIT STRING
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如 X.509 的 SubjectPublicKeyInfo：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SubjectPublicKeyInfo ::= SEQUENCE {
    algorithm AlgorithmIdentifier,
    publicKey BIT STRING
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BER 编码方式可以是 primitive 或者 constructed 的，DER 只允许 primitive 编码方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;primitive 编码方式：由于 bit string 可以是任意长度，不一定是 8 的整数倍，所以第一字节编码最后一个字节中填充的比特数（0～7），BER 填充比特可以是任意东西，但 DER 则只允许填充 0&lt;/li&gt;
&lt;li&gt;constructed 编码方式：这种编码方式把原来的一个 BIT STRING 分解成多个字串，分别编码之并串联起来；字串中除了最后一个，长度都必须是 8 的整数倍&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如对 &lt;code&gt;011011100101110111&lt;/code&gt; 进行编码（长度为 18，&lt;code&gt;01101110-01011101-11 (bin)&lt;/code&gt; &lt;code&gt;6e 5d c0 (hex)&lt;/code&gt;，填充 6 位）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DER 编码：&lt;code&gt;03 04 06 6e 5d c0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;BER constructed 方式编码：把原比特串划分成 &lt;code&gt;01101110-01011101&lt;/code&gt; 和 &lt;code&gt;11&lt;/code&gt; 分别编码得 &lt;code&gt;03 03 00 6e 5d&lt;/code&gt; 和 &lt;code&gt;03 02 06 c0&lt;/code&gt;，这两子串一共 9 字节，故最终编码为：&lt;code&gt;23 09 03 03 00 6e 5d 03 02 06 c0&lt;/code&gt;。（注意：第一个字节变成了 23，这是因为 primitive 标识位为 1）&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;octet-string&#34;&gt;OCTET STRING&lt;/h5&gt;

&lt;p&gt;tag number 为 4，任意长度的字节串，记法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OCTET STRING [ SIZE &#39;(&#39; size | size1 &#39;..&#39; size2 &#39;)&#39; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SIZE(size)&lt;/code&gt; 形式的表示字节串长度为 size，&lt;code&gt;SIZE(size1..size2)&lt;/code&gt; 形式的表示字符串长度需要在 size1 和 size2 之间，没有 &lt;code&gt;SIZE&lt;/code&gt; 后缀的表示字符串可以任意长度。&lt;/p&gt;

&lt;p&gt;BER 编码方式可以是 primitive 或者 constructed 的，constructed 编码方式类似 BIT STRING 一样由子串串联而成；DER 只允许 primitive 编码方式&lt;/p&gt;

&lt;h5 id=&#34;sequence&#34;&gt;SEQUENCE&lt;/h5&gt;

&lt;p&gt;tag number 为 16，相当于 c 语言中的 struct，记法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SEQUENCE {
    [identifier1] Type1 [ &#39;{&#39; ( &#39;OPTIONAL&#39; | &#39;DEFAULT&#39; value1 ) &#39;}&#39; ],
    ...,
    [identifiern] Typen [ &#39;{&#39; ( &#39;OPTIONAL&#39; | &#39;DEFAULT&#39; valuen ) &#39;}&#39; ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;identifierx&lt;/code&gt; 是字段名，主要起到名称作用所以可以不写；&lt;code&gt;Typex&lt;/code&gt; 则是对应字段的类型；字段如果带上 &lt;code&gt;OPTIONAL&lt;/code&gt; 表明此字段可以为空，如果带上 &lt;code&gt;DEFAULT valuex&lt;/code&gt; 同样表明此字段可以为空且有缺省值；相邻几个字段如果都是 &lt;code&gt;OPTIONAL&lt;/code&gt; 或者 &lt;code&gt;DEFAULT&lt;/code&gt; 的话，那么这几个字段以及后续的那个字段必须拥有不同的 tag 以避免歧义&lt;/p&gt;

&lt;p&gt;编码方式为 structured，字段按顺序编码串联而成；当某个字段空时，不用编码这个字段；假如刚好这个字段的值跟缺省值相同时，BER 编码可以也可以不包含此字段，DER 编码则不包含此字段&lt;/p&gt;

&lt;p&gt;例子，摘自 &lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One#Example&#34;&gt;wiki&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FooQuestion ::= SEQUENCE {
    trackingNumber INTEGER,
    question       IA5String
}

myQuestion FooQuestion ::= {
    trackingNumber     5,
    question           &amp;quot;Anybody there?&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编码为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;30 — type tag indicating SEQUENCE
13 — length in octets of value that follows
02 — type tag indicating INTEGER
01 — length in octets of value that follows
05 — value (5)
16 — type tag indicating IA5String 
     (IA5 means the full 7-bit ISO 646 set, including variants, 
      but is generally US-ASCII)
0e — length in octets of value that follows
41 6e 79 62 6f 64 79 20 74 68 65 72 65 3f — value (&amp;quot;Anybody there?&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;sequence-of&#34;&gt;SEQUENCE OF&lt;/h5&gt;

&lt;p&gt;相当于 c 中的 array，列表中的数据都是同一个类型的，编码方式跟 SEQUENCE 是一样的，只是记法不一样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SEQUENCE OF Type
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;set&#34;&gt;SET&lt;/h5&gt;

&lt;p&gt;tag number 是 17，字段无序的结构体，记法类似于 SEQUENCE，编码方式也类似于它，另有一个要求是字段必须有不一样的 tag number，DER 编码时字段按 tag number 排序&lt;/p&gt;

&lt;h5 id=&#34;set-of&#34;&gt;SET OF&lt;/h5&gt;

&lt;p&gt;类似于 SEQUENCE OF，只是是无序的，DER 编码时按照各个字段 BER 编码后的字串排序&lt;/p&gt;

&lt;h5 id=&#34;tagged-types&#34;&gt;Tagged types&lt;/h5&gt;

&lt;p&gt;tagged types 如前所述是对现有类型的封装，赋予新的 tag 成为新的类型。有两种 tagged 类形：&lt;code&gt;IMPLICIT&lt;/code&gt; 和 &lt;code&gt;EXPLICIT&lt;/code&gt;，只是编码方式不一样，记法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;[&#39; [ class ] number &#39;]&#39; [ &#39;IMPLICIT&#39; | &#39;EXPLICIT&#39; ] Type

class = &#39;UNIVERSAL&#39; | &#39;APPLICATION&#39; | &#39;PRIVATE&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Image ::= SEQUENCE {
    width  [0] INTEGER OPTIONAL,
    height [1] INTEGER OPTIONAL,
    data   OCTET STRING
}

myImage Image ::= {
    width 100,
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 &lt;code&gt;width&lt;/code&gt; 字段的原类型是 &lt;code&gt;INTEGER OPTIONAL&lt;/code&gt;，&lt;code&gt;[0]&lt;/code&gt; 表明这个 tagged 类型的 tag number 为 0，又因为 class 没指定，默认为 context-specific，而由于也没有指定 IMPLICIT 还是 EXPLICIT，默认是 EXPLICIT&lt;/p&gt;

&lt;p&gt;编码方式，对于 EXPLICIT tagged 类型，采用 constructed 编码方式，就像 SEQUENCE 一样，原类型数据则作为唯一一个字段进行编码。如上述例子对 width 的编码为：&lt;code&gt;a0 (10-1-00000) 03 02 01 64&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于 IMPLICIT tagged 类型的话，则只是把原类型数据的 tag 换成新的 tag，所以可能是 primitive 也可以能是 constructed 编码方式，length-octets 跟 content-octets 都不变&lt;/p&gt;

&lt;p&gt;对比两种 tagged 类型，EXPLICIT 更为完整，接收方可以立即解码出原类型数据；而 IMPLICIT 类型的编码更短，但接收方必须知道原类型才能解码出数据&lt;/p&gt;

&lt;h4 id=&#34;参考&#34;&gt;参考&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://luca.ntop.org/Teaching/Appunti/asn1.html&#34;&gt;http://luca.ntop.org/Teaching/Appunti/asn1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One&#34;&gt;https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/X.690#BER_encoding&#34;&gt;https://en.wikipedia.org/wiki/X.690#BER_encoding&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.obj-sys.com/asn1tutorial/asn1only.html&#34;&gt;https://www.obj-sys.com/asn1tutorial/asn1only.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Public Key Cryptography 笔记（2）-- 存储格式和标准</title>
      <link>//huangjunwen.github.io/post/2017/public-key-cryptography-notes-2-format-and-standard/</link>
      <pubDate>Thu, 26 Jan 2017 17:43:37 +0800</pubDate>
      
      <guid>//huangjunwen.github.io/post/2017/public-key-cryptography-notes-2-format-and-standard/</guid>
      <description>

&lt;h3 id=&#34;rsa-on-disk&#34;&gt;RSA on disk&lt;/h3&gt;

&lt;p&gt;如前所描述，RSA 的公私钥实际上就是些数字，但我们平时实际使用的是 .pem 格式（或 .der）的 key 。&lt;/p&gt;

&lt;p&gt;.pem 格式头部和尾部的有一些标识符（&lt;code&gt;-----BEGIN XXXX-----&lt;/code&gt;）这些是为了让 parser 可以马上知道这个文件包含的是公钥私钥，或是证书等。&lt;/p&gt;

&lt;p&gt;中间的数据其实是 base64 编码过后的 &lt;a href=&#34;https://en.wikipedia.org/wiki/X.690#DER_encoding&#34;&gt;DER（Distinguished Encoding Rules）&lt;/a&gt; 编码的 &lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One&#34;&gt;ASN.1（Abstract Syntax Notation One）&lt;/a&gt; 数据。&lt;/p&gt;

&lt;p&gt;写个程序验证以下（dec.py）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python

import sys
from base64 import b64decode
from pyasn1.codec.der.decoder import decode as der_decode

def read_pem(f, asn1Spec=None):

    return der_decode(
        b64decode(
            &#39;&#39;.join([line.strip() for line in f if not line.startswith(&#39;-----&#39;)])
        ), asn1Spec=asn1Spec
    )

obj, _ = read_pem(open(sys.argv[1]))

print obj.prettyPrint()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找一个 rsa private key 来跑一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./dec.py ca-key.pem
Sequence:
 &amp;lt;no-name&amp;gt;=0
 &amp;lt;no-name&amp;gt;=893023574113042040269634126903705690958192000367515749793690532339562261663040768984677949208969821111506076369919400865801870985710613745908260652498336371620343220418005606803657105824685015775676961140056140842104922723725658584469937036979589039943318206308234450689935285531106176400784666850060612721223693026581160586984891869615299748396327063287952075098361379463194619694679249727200666343866879641226753061213723029674074572257689929441761207652940540816182884905731304910753429627574542805302378789826317425085431344299593860348296475098275788724990249961382297055893837789210216811880295130941496086631466846898230102127302757337004369112580595622821486216735822235200640222222944221601570231272966140106941857253100312153098428839206633396871491965363584739634413789118376819458819246161914101471359882766752512369669989338842342284961310600856321697107602376430660404437017714184604092513856991285419405296956080590982024711058544298854586244916166800299716510005045028393869316903124931993350151904669792718044403523729143307225465547206325525108357699688142798085183620461364419641399258446567984823312671315017896056518369422953112217687200988245732031363722479836324436839592416038603174283616122293984715039728219
 &amp;lt;no-name&amp;gt;=65537
 &amp;lt;no-name&amp;gt;=.....
....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ASN.1 中 Sequence 相当于一般语言里的 struct，所以这个 private key 里是一个结构体，包含七八个数字，但所有字段名字都是 &lt;code&gt;&amp;lt;no-name&amp;gt;&lt;/code&gt;，这是因为没有指定 specifiction。&lt;/p&gt;

&lt;p&gt;修改一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ...
from pyasn1_modules import rfc2437

# ...
obj, _ = read_pem(open(sys.argv[1]), asn1Spec=rfc2437.RSAPrivateKey())
# ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新运行一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./dec.py ca-key.pem
RSAPrivateKey:
 version=0
 modulus=893023574113042040269634126903705690958192000367515749793690532339562261663040768984677949208969821111506076369919400865801870985710613745908260652498336371620343220418005606803657105824685015775676961140056140842104922723725658584469937036979589039943318206308234450689935285531106176400784666850060612721223693026581160586984891869615299748396327063287952075098361379463194619694679249727200666343866879641226753061213723029674074572257689929441761207652940540816182884905731304910753429627574542805302378789826317425085431344299593860348296475098275788724990249961382297055893837789210216811880295130941496086631466846898230102127302757337004369112580595622821486216735822235200640222222944221601570231272966140106941857253100312153098428839206633396871491965363584739634413789118376819458819246161914101471359882766752512369669989338842342284961310600856321697107602376430660404437017714184604092513856991285419405296956080590982024711058544298854586244916166800299716510005045028393869316903124931993350151904669792718044403523729143307225465547206325525108357699688142798085183620461364419641399258446567984823312671315017896056518369422953112217687200988245732031363722479836324436839592416038603174283616122293984715039728219
 publicExponent=65537
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整的定义是在 &lt;a href=&#34;https://en.wikipedia.org/wiki/PKCS_1&#34;&gt;PKCS#1&lt;/a&gt; 标准中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RSAPrivateKey ::= SEQUENCE {
  version           Version,
  modulus           INTEGER,  -- n
  publicExponent    INTEGER,  -- e
  privateExponent   INTEGER,  -- d
  prime1            INTEGER,  -- p
  prime2            INTEGER,  -- q
  exponent1         INTEGER,  -- d mod (p-1)
  exponent2         INTEGER,  -- d mod (q-1)
  coefficient       INTEGER,  -- (inverse of q) mod p
  otherPrimeInfos   OtherPrimeInfos OPTIONAL
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 modulus/publicExponent/privateExponent 即模／公钥幂／私钥幂，可以看到实际中的 RSA 私钥也是包含 publicExponent 的；所以这就是为什么 openssl 工具中能从私钥中导出公钥的原因。&lt;/p&gt;

&lt;p&gt;剩下的其它参数则是使用中国剩余定理加速计算而预先计算好的参数。&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://luca.ntop.org/Teaching/Appunti/asn1.html&#34;&gt;http://luca.ntop.org/Teaching/Appunti/asn1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.emc.com/collateral/white-papers/h11300-pkcs-1v2-2-rsa-cryptography-standard-wp.pdf&#34;&gt;https://www.emc.com/collateral/white-papers/h11300-pkcs-1v2-2-rsa-cryptography-standard-wp.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tls.mbed.org/kb/cryptography/asn1-key-structures-in-der-and-pem&#34;&gt;https://tls.mbed.org/kb/cryptography/asn1-key-structures-in-der-and-pem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://crypto.stackexchange.com/questions/1729/why-does-the-pkcs1-rsa-private-key-structure-contain-more-than-just-exponent-and&#34;&gt;http://crypto.stackexchange.com/questions/1729/why-does-the-pkcs1-rsa-private-key-structure-contain-more-than-just-exponent-and&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/16899247/how-can-i-decode-a-ssl-certificate-using-python&#34;&gt;http://stackoverflow.com/questions/16899247/how-can-i-decode-a-ssl-certificate-using-python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Public Key Cryptography 笔记（1）-- RSA</title>
      <link>//huangjunwen.github.io/post/2017/public-key-cryptography-notes-1-rsa/</link>
      <pubDate>Tue, 24 Jan 2017 11:52:55 +0800</pubDate>
      
      <guid>//huangjunwen.github.io/post/2017/public-key-cryptography-notes-1-rsa/</guid>
      <description>

&lt;script type=&#34;text/javascript&#34; async src=&#34;//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&#34;&gt;&lt;/script&gt;


&lt;p&gt;这一系列的笔记主要是对学习到的公钥加密体系知识的记录和梳理，主要以 RSA 算法为代表，以及从中衍生开去的各种应用：ssl/tls，ssh，gpg 等等我们每天都依赖的东西。&lt;/p&gt;

&lt;h3 id=&#34;rsa-主要原理&#34;&gt;RSA 主要原理&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/RSA_(cryptosystem)&#34;&gt;RSA&lt;/a&gt; 的原理是在于能够找到三个很大的正整数 &lt;span&gt;\(e,d,n\)&lt;/span&gt;
 使得对于任何 &lt;span&gt;\(0\le{m}\lt{n}\)&lt;/span&gt;
：&lt;/p&gt;

&lt;span&gt;$$(m^e)^d\equiv m\pmod{n}$$&lt;/span&gt;


&lt;p&gt;其中公钥为 &lt;span&gt;\((n,e)\)&lt;/span&gt;
，可以发送给任何人；私钥为 &lt;span&gt;\((n,d)\)&lt;/span&gt;
，只能由所有者掌握。RSA 支持 4 种操作：加密／解密，签名／验证签名。&lt;/p&gt;

&lt;h4 id=&#34;加密&#34;&gt;加密&lt;/h4&gt;

&lt;p&gt;首先用一些编码手段把需要加密的信息转换成整数 &lt;span&gt;\(m\)&lt;/span&gt;
 ，用公钥中的两个参数计算&lt;/p&gt;

&lt;span&gt;$$c=m^e\pmod{n}$$&lt;/span&gt;


&lt;p&gt;&lt;span&gt;\(c\)&lt;/span&gt;
 就是加密后的信息了。&lt;/p&gt;

&lt;h4 id=&#34;解密&#34;&gt;解密&lt;/h4&gt;

&lt;p&gt;中学知识温习时间：&lt;/p&gt;

&lt;span&gt;$$ab\pmod{n}\\=(xn&amp;#43;a_r)(yn&amp;#43;b_r)\pmod{n}\\={a_r}{b_r}\pmod{n}\\=(a\pmod{n})(b\pmod{n})\pmod{n}$$&lt;/span&gt;


&lt;p&gt;所以：&lt;/p&gt;

&lt;span&gt;$$x^y\pmod{n}\\=(xx...x)\pmod{n}\\=(x\pmod{n})(x\pmod{n})...\pmod{n}\\=(x\pmod{n})^y\pmod{n}$$&lt;/span&gt;


&lt;p&gt;即在模运算中，只要算余数就可以了。&lt;/p&gt;

&lt;p&gt;由私钥所有者计算&lt;/p&gt;

&lt;span&gt;$$c^d\pmod{n}=(m^e\pmod{n})^d\pmod{n}=(m^e)^d\pmod{n}=m\pmod{n}$$&lt;/span&gt;


&lt;p&gt;就能还原原来的信息了。&lt;del&gt;（数学差真啰嗦啊。。。）&lt;/del&gt;&lt;/p&gt;

&lt;h4 id=&#34;签名&#34;&gt;签名&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;首先对要签名的信息作一个 &lt;a href=&#34;https://en.wikipedia.org/wiki/Cryptographic_hash_function&#34;&gt;message digest&lt;/a&gt;，常用的如 MD5 和 SHA 系列；&lt;/li&gt;
&lt;li&gt;然后把这个 digest 转换成整数 &lt;span&gt;\(m\)&lt;/span&gt;
 使得 &lt;span&gt;\(1\le{m}\lt{n}\)&lt;/span&gt;
；&lt;/li&gt;
&lt;li&gt;最后用私钥 &lt;span&gt;\((n,d)\)&lt;/span&gt;
 计算 &lt;span&gt;\(s=m^d\pmod{n}\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;验证签名&#34;&gt;验证签名&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;用公钥 &lt;span&gt;\((n,e)\)&lt;/span&gt;
 计算 &lt;span&gt;\(v=s^e\pmod{n}\)&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;把 &lt;span&gt;\(v\)&lt;/span&gt;
 转换回 digest&lt;/li&gt;
&lt;li&gt;独立对要签名的信息再作一次 digest&lt;/li&gt;
&lt;li&gt;对比这两个 digest，如果相同的话，那这个签名就是有效的&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;小结&#34;&gt;小结&lt;/h4&gt;

&lt;p&gt;可以看到加解密和签名验签刚好是两个方向：前者是公钥加密发送给所有者解密，后者是用私钥签名发送给其他人用公钥验签；所以这就是为何一般&lt;a href=&#34;http://www.di-mgt.com.au/rsa_alg.html#weaknesses&#34;&gt;不建议使用相同的 key 同时用作加密和签名&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Using the same key for encryption and signing
Given that the underlying mathematics is the same for encryption and signing, only in reverse, if an attacker can convince a key holder to sign an unformatted encrypted message using the same key then she gets the original.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;实际算法&#34;&gt;实际算法&lt;/h3&gt;

&lt;p&gt;包括 key 的生成算法，计算时的优化，对信息的编码等，以及 RSA 的数学上的证明；有兴趣可以看一下下面参考的链接，稍微摘录一些简单而重要的点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计算 &lt;span&gt;\(y=x^e\pmod{n}\)&lt;/span&gt;
 （所谓 modular exponentiation）的复杂度大约为 &lt;span&gt;\(O(k^3)\)&lt;/span&gt;
，其中 &lt;span&gt;\(k\)&lt;/span&gt;
 是 &lt;span&gt;\(n\)&lt;/span&gt;
 的长度（例如 1024 bits），且当 &lt;span&gt;\(e\)&lt;/span&gt;
 的二进制表示中 1 的数量越多则越慢。&lt;/li&gt;
&lt;li&gt;公钥幂 &lt;span&gt;\(e\)&lt;/span&gt;
 一般选取固定的：例如
&lt;span&gt;$$3=2^{2^0}&amp;#43;1\\5=2^{2^1}&amp;#43;1\\17=2^{2^2}&amp;#43;1\\257=2^{2^3}&amp;#43;1\\65537=2^{2^4}&amp;#43;1$$&lt;/span&gt;

这5个是前五个 fermat number：&lt;span&gt;\(F_x=2^{2^x}&amp;#43;1\)&lt;/span&gt;
 ，恰好都是素数，但 &lt;span&gt;\(F_5\)&lt;/span&gt;
 以及后面的 fermat number 不是素数。显然这些数字的二进制表示只有两个 1，如上述原因，在加密的过程中能节省计算时间。实际应用中一般都是使用 65537 ，因为小的 &lt;span&gt;\(e\)&lt;/span&gt;
 不太安全。&lt;/li&gt;
&lt;li&gt;模 &lt;span&gt;\(n\)&lt;/span&gt;
 一般是由两个( &lt;span&gt;\(n=pq\)&lt;/span&gt;
 )或更多个随机产生（且满足一些数学条件）的大素数（所谓 &amp;ldquo;multi-prime&amp;rdquo; RSA）相乘而得。&lt;/li&gt;
&lt;li&gt;私钥幂 &lt;span&gt;\(d\)&lt;/span&gt;
 是从模 &lt;span&gt;\(n\)&lt;/span&gt;
 的因子（&lt;span&gt;\(p,q\)&lt;/span&gt;
）以及 &lt;span&gt;\(e\)&lt;/span&gt;
 推导出来，由于模是公开的（公钥的一部分），故 RSA 的其中一个安全因素在于：&lt;a href=&#34;https://en.wikipedia.org/wiki/Integer_factorization&#34;&gt;分解一个大数&lt;/a&gt;是困难的。&lt;/li&gt;
&lt;li&gt;多个素数相乘结果作为模的一个好处是可以更快速的计算 &lt;span&gt;\(m=c^d\pmod{n}\)&lt;/span&gt;


&lt;ul&gt;
&lt;li&gt;使用中国剩余定理（Chinese Remainder Theorem，CRT）可以把这个计算转换成对 &lt;span&gt;\(p,q\)&lt;/span&gt;
 的 modular exponentiation 计算，而 &lt;span&gt;\(p, q\)&lt;/span&gt;
 的长度都只有 &lt;span&gt;\(n\)&lt;/span&gt;
 的一半，所以复杂度会降低到原来的&lt;a href=&#34;http://www.di-mgt.com.au/crt_rsa.html#crtarithmetic&#34;&gt;四分之一&lt;/a&gt;：&lt;span&gt;\(O(2(\cfrac{k}{2})^3)=O(\cfrac{k^3}{4})\)&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.di-mgt.com.au/rsa_alg.html&#34;&gt;http://www.di-mgt.com.au/rsa_alg.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.di-mgt.com.au/rsa_theory.html&#34;&gt;http://www.di-mgt.com.au/rsa_theory.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>用 iptables 来配置 port knocking</title>
      <link>//huangjunwen.github.io/post/2016/port-knocking-using-iptables/</link>
      <pubDate>Tue, 20 Dec 2016 10:20:54 +0800</pubDate>
      
      <guid>//huangjunwen.github.io/post/2016/port-knocking-using-iptables/</guid>
      <description>&lt;p&gt;对于正式环境的服务器来说，每当查看到 auth.log 里头那些撞大运的 ssh 登录尝试，心里总是有点惴惴不安的。虽然 public key authentication 号称安全，但是谁说得准呢？而且不知道配置里会不会有错误，要是有多一层的防护总是好的。&lt;/p&gt;

&lt;p&gt;以前听说过 &lt;a href=&#34;https://en.wikipedia.org/wiki/Port_knocking&#34;&gt;Port knocking&lt;/a&gt; 这种技术了，大致的思路就是设定一系列随机端口（例如：7421，3411，9088等等）作为暗号，用户在访问服务器之前，要依次“敲”一下这几个端口（即相继发送网络包到这几个端口上），这些端口当然是关闭状态啦，但服务器上可以侦察得到这些敲门，如果暗号对了，就给访问者 ip 开放服务端口（例如22）。&lt;/p&gt;

&lt;p&gt;还有一些更高级的，例如在网络包里存放加密信息等，不过这就复杂了，暂且不表。&lt;/p&gt;

&lt;p&gt;一般要实现这样的功能，需要有独立的 deamon 程序跑在后台检查日志，但有个问题，如果这个 deamon 不够健壮挂了的话，就再也没人上得去了。&lt;/p&gt;

&lt;p&gt;前段时间看到 &lt;a href=&#34;https://www.digitalocean.com/&#34;&gt;DigitalOcean&lt;/a&gt; 上一篇单纯使用 iptables 就能实现 Port knocking 的教程，不需要单独开发 deamon，只要配置 iptables 的 rules 就能实现这样的功能，觉得很实用，分享在此：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.digitalocean.com/community/tutorials/how-to-configure-port-knocking-using-only-iptables-on-an-ubuntu-vps&#34;&gt;https://www.digitalocean.com/community/tutorials/how-to-configure-port-knocking-using-only-iptables-on-an-ubuntu-vps&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不过我用的时候发现个问题，就是 tcp 包在发送的时候，好像一次过会发送多个包，这样敲门的序列就会变成类似：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;7421
7421
3411
9088
9088
9088
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以我把 rules 改成接纳每个端口可以连续 N 次，只要下一个不一样的是正确的就可以接受：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

PORT1=xxxx
PORT2=xxxx
PORT3=xxxx

# reset firewall
iptables -F
iptables -X
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT

# create new chains used by port knocking
iptables -N KNOCKING
iptables -N GATE1
iptables -N GATE2
iptables -N GATE3
iptables -N PASSED

# accept current connections (keep current SSH connections)
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# accept local machine&#39;s connection
iptables -A INPUT -i lo -j ACCEPT

# accept http/https or other exported services
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT

# now pass all other to the KNOCKING chain
iptables -A INPUT -j KNOCKING

# KNOCKING dispatch
iptables -A KNOCKING -m recent --reap --rcheck --seconds 3600 --name AUTH3 -j PASSED
iptables -A KNOCKING -m recent --reap --rcheck --seconds 10 --name AUTH2 -j GATE3
iptables -A KNOCKING -m recent --reap --rcheck --seconds 10 --name AUTH1 -j GATE2
iptables -A KNOCKING -j GATE1

iptables -A GATE1 -p tcp --dport $PORT1 -m recent --name AUTH1 --set -j DROP
iptables -A GATE1 -j DROP

iptables -A GATE2 -p tcp --dport $PORT1 -j DROP         # allow $PORT1 duplication
iptables -A GATE2 -m recent --name AUTH1 --remove
iptables -A GATE2 -p tcp --dport $PORT2 -m recent --name AUTH2 --set -j DROP
iptables -A GATE2 -j GATE1

iptables -A GATE3 -p tcp --dport $PORT2 -j DROP         # allow $PORT2 duplication
iptables -A GATE3 -m recent --name AUTH2 --remove
iptables -A GATE3 -p tcp --dport $PORT3 -m recent --name AUTH3 --set -j DROP
iptables -A GATE3 -j GATE1

iptables -A PASSED -p tcp --dport $PORT3 -j DROP        # allow $PORT3 duplication
iptables -A PASSED -p tcp --dport 22 -j ACCEPT
iptables -A PASSED -j DROP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外还有些修改，例如 AUTH3 的时候，允许用户有一个小时（3600秒）的时间可以随意连接 22 端口。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>免输入密码登录 mysql</title>
      <link>//huangjunwen.github.io/post/2016/mysql-client-auto-login-without-password/</link>
      <pubDate>Sun, 18 Dec 2016 09:58:58 +0800</pubDate>
      
      <guid>//huangjunwen.github.io/post/2016/mysql-client-auto-login-without-password/</guid>
      <description>

&lt;p&gt;对于一些 &lt;del&gt;(古董)&lt;/del&gt; mysql 管理员来说，直接用 mysql client 连接生产环境的数据库进行操作是很常见的事情。&lt;/p&gt;

&lt;p&gt;根据 Mysql 的 &lt;a href=&#34;http://dev.mysql.com/doc/refman/5.5/en/password-security-user.html&#34;&gt;End-User Guidelines for Password Security&lt;/a&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在 command line 上用 &lt;code&gt;-p xxxxx&lt;/code&gt; 直接指定密码是很危险的，因为别人 &lt;code&gt;ps&lt;/code&gt; 一下就看到了。&lt;/li&gt;
&lt;li&gt;在 command line 上用 &lt;code&gt;-p&lt;/code&gt; 然后在 prompt 中输入密码，这样相对安全得多，但这样得手动输入了。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;~/.my.cnf&lt;/code&gt; 里写下 password，似乎两者兼得唯有此法，但这个配置始终是明文的，感觉还是不太安全。&lt;/li&gt;
&lt;li&gt;设置在 &lt;code&gt;MYSQL_PWD&lt;/code&gt; 环境变量中，extremely insecure and should not be used&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因为之前有&lt;a href=&#34;https://blog.erincall.com/p/using-pgp-to-encrypt-the-ansible-vault&#34;&gt;用 GPG 加密 ansible 的 vault 密码&lt;/a&gt;的经验： gpg 负责加密，gpg-agent 负责偷懒；我想也能用在这里吧。&lt;/p&gt;

&lt;p&gt;首先设定最终要达到的效果：在 local machine 上执行一个脚本，它会通过 gpg-agent 解密出连接参数，再 ssh 到生产环境机器上（生产数据库只能由生产环境的 ip 访问），执行 mysql client 进行连接和操作。&lt;/p&gt;

&lt;h3 id=&#34;初步尝试&#34;&gt;初步尝试&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
$ ssh $SSH_HOST &amp;quot;mysql -p -h $DB_HOST -u $DB_UESR $DB_NAME&amp;quot;
Enter password: xxxxxx
show tables;

^D
Tables_in_DB_NAME
xxx
yyy
...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里密码会回显，且输入的命令（&lt;code&gt;show tables;&lt;/code&gt;）直到输入 Ctrl+D （EOF）才执行，返回的结果是 &lt;a href=&#34;http://dev.mysql.com/doc/refman/5.5/en/batch-mode.html&#34;&gt;batch mode&lt;/a&gt; 格式的。似乎当 mysql client 的标准输入如果不是 tty 的话，则会进入 batch mode: &lt;a href=&#34;https://github.com/mysql/mysql-server/blob/5.7/client/mysql.cc#L1259&#34;&gt;https://github.com/mysql/mysql-server/blob/5.7/client/mysql.cc#L1259&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;让-ssh-分配-tty&#34;&gt;让 ssh 分配 tty&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
$ ssh -t $SSH_HOST &amp;quot;mysql -p -h $DB_HOST -u $DB_UESR $DB_NAME&amp;quot;
Enter password:
Reading table information for completion of table and column names
...
...
Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.

mysql&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ssh 加上 &lt;code&gt;-t&lt;/code&gt;，输入密码，进入 interactive mode，一切正常。&lt;/p&gt;

&lt;h3 id=&#34;自动输入密码&#34;&gt;自动输入密码&lt;/h3&gt;

&lt;p&gt;要实现自动输入密码，相当于将密码文本和当前终端的输入连接起来，那用 &lt;code&gt;cat&lt;/code&gt; 命令应该就能实现这个功能：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!bin/bash

cur_tty=&amp;quot;$( tty )&amp;quot;

echo $DB_PASSWORD | cat - $cur_tty | ssh -tt $SSH_HOST &amp;quot;mysql -p -h $DB_HOST -u $DB_UESR $DB_NAME&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 &lt;code&gt;ssh -tt&lt;/code&gt; 为什么又多了一个 &lt;code&gt;-t&lt;/code&gt; 呢？因为对 ssh 来说，它的标准输入不再是 tty 了（而是 cat 的标准输出 pipe），如果不多加一个 &lt;code&gt;-t&lt;/code&gt; 它不会分配 tty 的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-t  Force pseudo-terminal allocation.  This can be used to execute arbitrary screen-based programs on a remote machine, which can be very useful, e.g. when implementing menu services. Multiple -t options force tty allocation, even if ssh has no local tty.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./mysql.sh
Enter password:
...
...
Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.

mysql&amp;gt; show tables;
show tables;
+-------------------+
| Tables_in_DB_NAME |
+-------------------+
| xxxx              |
| yyyy              |
| ...               |
+-------------------+

mysql&amp;gt; ^[[A

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不需要输入密码了，而且正确进入 interactive mode，但是编辑命令的时候跟原来有点不一样，例如命令会回显多一次，按 UP 键没有出现上一句命令而是 &amp;lsquo;^[[A&amp;rsquo;，要再按一次回车，上一句就直接执行了。这应该是因为 locale machine 的 tty 会 buffer 住当前行用于编辑，直到按回车才发送出去。&lt;/p&gt;

&lt;p&gt;这是多此一举的，正确的方式是 locale machine 上输入什么，原原本本马上发送过去就好了。&lt;/p&gt;

&lt;h3 id=&#34;stty-raw-mode&#34;&gt;stty raw mode&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!bin/bash

#...

stty_state=&amp;quot;$( stty -g )&amp;quot;

trap &amp;quot;stty $stty_state&amp;quot; EXIT

stty raw -echo

#...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code&gt;stty&lt;/code&gt; 命令来实现这个调整，首先 &lt;code&gt;stty -g&lt;/code&gt; 保存当前 tty 的设置，设置一个 EXIT 的 trap，在这个脚本退出时恢复设置，然后进入 raw 模式。（不过 linux 下的 stty raw 不包括 &lt;code&gt;-echo&lt;/code&gt;，所以这里加上）&lt;/p&gt;

&lt;h3 id=&#34;gpg-解密参数&#34;&gt;gpg 解密参数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
#!/bin/bash

# ...

# extract options from db_credential.sh.gpg, expected in db_credential.sh:
#
# SSH_USER=xxxx
# SSH_HOST=xxxx
# DB_USER=xxxx
# DB_HOST=xxxx
# DB_NAME=xxxx
# DB_PASSWORD=xxxx
eval `gpg --batch --use-agent --decrypt db_credential.sh.gpg`

# ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;db_credential.sh&lt;/code&gt; 中写好 ssh 跟数据的连接参数，然后用 &lt;code&gt;gpg --encrypt -r your@email db_credential.sh&lt;/code&gt; 加密；脚本里则直接用 &lt;code&gt;eval&lt;/code&gt; 取出解密出来的内容。&lt;/p&gt;

&lt;h3 id=&#34;最终&#34;&gt;最终&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
#!/bin/bash

# extract options from db_credential.sh.gpg, expected in db_credential.sh:
#
# SSH_USER=xxxx
# SSH_HOST=xxxx
# DB_USER=xxxx
# DB_HOST=xxxx
# DB_NAME=xxxx
# DB_PASSWORD=xxxx
eval `gpg --batch --use-agent --decrypt db_credential.sh.gpg`

cur_tty=&amp;quot;$( tty )&amp;quot;

stty_state=&amp;quot;$( stty -g )&amp;quot;

trap &amp;quot;stty $stty_state&amp;quot; EXIT

stty raw -echo

echo $DB_PASSWORD | cat - $cur_tty | ssh -tt -a $SSH_HOST &amp;quot;mysql -p -h $DB_HOST -u $DB_UESR $DB_NAME&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：ssh 的配置里如果 &lt;code&gt;ForwardAgent yes&lt;/code&gt; 的话，似乎不能正常工作，还没找出原因，所以这里加上 &lt;code&gt;-a&lt;/code&gt; 显式地禁用它，因为这个脚本只是用来连数据库的，并不需要用到 ssh authentication。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>