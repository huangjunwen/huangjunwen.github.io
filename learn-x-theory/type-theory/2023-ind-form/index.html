<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="HJW" />
  <meta name="dcterms.date" content="2023-08-31" />
  <title>Form of Induction Type</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link href="/assets/latex.css/style.min.css" rel="stylesheet" />
  <style>
  /* fixes for latex.css */
  .date {
    text-align: center;
  }

  div.sourceCode {
    background: var(--pre-bg-color);
    border-radius: 10px;
  }

  dl dd {
    text-align: left;
  }

  #footnotes {
    margin-top: 1em;
  }

  #footnotes hr:first-child {
    display: none;
  }
  </style>
  <script src="/assets/mathjax/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<style>
/* sidebar */
#sidebar {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 999;
  max-width: 400px;
  width: 80%;
  height: 100%;
  padding: 2rem;
  background-color: #eee;
  box-shadow: 0 10px 20px -4px #000;
  overflow-x: hidden;
  overflow-y: auto;
  pointer-events: none;
  opacity: 0;
  visibility: hidden;
  transform: translateX(-100%);
  transition: opacity 0.3s ease, visibility 0.2s ease, transform 0.3s ease;
}
#sidebar.show {
  pointer-events: all;
  opacity: 1;
  visibility: visible;
  transform: translateX(0);
}
#sidebar_toggler {
  position: fixed;
  top: 4vh;
  right: 3vw;
  z-index: 1000;
  width: 2.8rem;
  height: 2.4rem;
  padding: 0.5rem;
  border: solid #999 0.1rem;
  border-radius: 0.4rem;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  cursor: pointer;
  overflow: hidden;
}

#sidebar_toggler span {
  background-color: #999;
  width: 100%;
  height: 0.2rem;
  transition: all 0.3s ease;
  pointer-events: none;
}
nav span {
  display: inline-block;
  overflow: hidden;
  /* text-overflow: ellipsis; */
  /* white-space: nowrap; */
  white-space: pre-wrap;
  width: 90%;
}
nav li:before {
  content: '';
}
nav span:before {
  content: "\25CF";
  margin-right: 8px;
}
nav .caret {
  cursor: pointer;
  user-select: none; /* Prevent text selection */
}
nav .caret::before {
  content: "\25B6";
  color: black;
  display: inline-block;
  margin-right: 6px;
}
nav .caret-down::before {
  transform: rotate(90deg);
}
nav .collapse {
  display: none;
}
</style>
<aside id="sidebar">
  <div class="sidebar_content sidebar_head">
    <h1>Content</h1>
  </div>
  <div class="sidebar_content sidebar_body">
    <nav id="side_navlinks" class="side_navlinks">
      <!--<ul>
        <li><a href="#">Home</a></li>
        <li><a href="#">About</a></li>
        <li><a href="#">Services</a></li>
        <li><a href="#">Portfolio</a></li>
        <li><a href="#">Contact</a></li>
      </ul>-->
    </nav>
  </div>
</aside>
<div id="sidebar_toggler">
  <span></span>
  <span></span>
  <span></span>
</div>
<script>
/* setup sidebar */
// https://www.cssscript.com/demo/responsive-sidebar-nav-hamburger/
const sidebar = document.querySelector('#sidebar')
const sidebarToggler = document.querySelector('#sidebar_toggler')

sidebarToggler.addEventListener('click', () => {
  sidebar.classList.toggle('show')
});

const keywords = document.querySelector('meta[name="keywords"]')
if (keywords && keywords.content.includes('showSidebar')) {
  sidebar.classList.add('show')
}

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    sidebar.classList.remove('show')
  }
})

window.addEventListener('click', (e) => {
  if (!sidebar.contains(e.target) && !sidebarToggler.contains(e.target)) {
    sidebar.classList.remove('show')
  }
});

/* load urls */
// https://www.w3schools.com/howto/howto_js_treeview.asp
const currentPath = window.location.pathname
const sideNavLinks = document.querySelector('#side_navlinks');
function buildSideLink(li, node) {
  // span contains the text and link (if provided)
  const span = li.appendChild(document.createElement("span"))
  if (node.url) {
    const a = span.appendChild(document.createElement("a"))
    a.href = node.url
    a.textContent = node.text
  } else {
    span.textContent = node.text
  }
  span.setAttribute("title", node.text)

  // if has children, then add caret and append a nested <ul> for children
  if (node.children.length > 0) {
    span.classList.add("caret")
    const ul = li.appendChild(document.createElement("ul"))
    ul.classList.add("nested")
    // do not collapse current path
    if (!currentPath.startsWith(node.path)) {
      ul.classList.add("collapse")
    } else {
      span.classList.add("caret-down")
    }
    node.children.forEach((child) => {
      const l = ul.appendChild(document.createElement("li"))
      buildSideLink(l, child)
    })
  }
}
async function loadSideLinks() {
  const resp = await fetch("/urls.json")
  const data = await resp.json()
  // console.log(data)
  const root = sideNavLinks.appendChild(document.createElement("ul"))
  data.children.forEach((child) => {
    buildSideLink(root.appendChild(document.createElement("li")), child)
  })

  const toggler = root.getElementsByClassName("caret")
  for (let i=0; i<toggler.length; i++) {
    toggler[i].addEventListener("click", function () {
      this.parentElement.querySelector(".nested").classList.toggle("collapse")
      this.classList.toggle("caret-down")
      return false
    })
  }
}
loadSideLinks()
</script>
<header id="title-block-header">
<h1 class="title">Form of Induction Type</h1>
<p class="author">HJW</p>
<p class="date">2023-08-31</p>
</header>
<p>以 Agda (Coq 类似) 为例总结一下 Inductive Type 的一般形式 <a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> ：</p>
<h2 id="general-form">General Form</h2>
<div class="sourceCode" id="cb1"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> T <span class="ot">(</span>p₁ <span class="ot">:</span> P₁<span class="ot">)</span> <span class="ot">...</span> <span class="ot">(</span>pₖ <span class="ot">:</span> Pₖ<span class="ot">)</span> <span class="ot">:</span> <span class="ot">(</span>i₁ <span class="ot">:</span> I₁<span class="ot">)</span> <span class="ot">→</span> <span class="ot">...</span> <span class="ot">→</span> <span class="ot">(</span>iⱼ <span class="ot">:</span> Iⱼ<span class="ot">)</span> <span class="ot">→</span> <span class="dt">Set</span> l <span class="kw">where</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  c <span class="ot">:</span> <span class="ot">(</span>a₁ <span class="ot">:</span> A₁<span class="ot">)</span> <span class="ot">→</span> <span class="ot">...</span> <span class="ot">→</span> <span class="ot">(</span>aₘ <span class="ot">:</span> Aₘ<span class="ot">)</span> <span class="ot">→</span> T p₁ <span class="ot">...</span> pₖ t₁  <span class="ot">...</span> tⱼ</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">...</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Aₓ can be either:</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">--   1. Non inductive and does not mention `T` at all</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">--   2. Or inductive in the form</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">--        `(b₁ : B₁) → ... → (bₙ : Bₙ) → T q₁ ... qₖ s₁  ... sⱼ`</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">--      Where `T` must not occur in any `Bₙ`</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>说明</p>
<ul>
<li><code>data ... where</code> 定义类型本身，相当于
<mark><strong><em>Formation Rule</em></strong></mark>
<ul>
<li><code>(p₁ : P₁) ... (pₖ : Pₖ)</code> <a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> 是
type 的 <em>parameters</em>，相当于来自整个类型的参数， 所有
constructors 构造出来的都必须具有这些相同的 parameters</li>
<li><code>(i₁ : I₁) → ... → (iⱼ : Iⱼ)</code> <a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>
则是 type family 的 <em>indices</em>，不同于 parameters，不同的
constructors 构造出来的可以是不同的（<code>t₁  ... tⱼ</code>
部分）；其实 parameters 也可以视为
indices，只不过因为它在整个定义里是一致的，所以可以提取出来放到前面，一般影响的是整个
type 的行为，而不一致的 index 则可以表达 type family 内 terms
之间复杂的关系</li>
</ul></li>
<li><code>c</code> 是 constructor，可以有 0+ 个 （例如 bottom type 没有
constructor），相当于 <mark><strong><em>Introduction
Rules</em></strong></mark>
<ul>
<li><p>每一个 constructor 最右边 <code>T p₁ ... pₖ t₁  ... tⱼ</code>
是必须的，表达构造出来的 term 所属类型</p></li>
<li><p>每一个 constructor 还可以有 <code>m</code> 个不同的参数
<code>aₓ : Aₓ (1 ≤ x ≤ m)</code>，但这些参数必须满足 Strict positivity
<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a> ，简单说就是正在定义的类型不能出现在
“箭头” 的左边:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Bad <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  bad <span class="ot">:</span> <span class="ot">(</span>Bad <span class="ot">→</span> Bad<span class="ot">)</span> <span class="ot">→</span> Bad</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">--     A     B      C</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- A is in a negative position, B and C are OK</span></span></code></pre></div></li>
</ul></li>
</ul>
<h2 id="explanation">Explanation</h2>
<p>上面完整的一般形式看上去挺复杂的，尤其是 Strict Positive 是为什么呢？
<a href="https://cs.stackexchange.com/a/55674/155579">这里</a> (By <a
href="https://stackexchange.com/users/168698/andrej-bauer">Andrej
Bauer</a>) 有一个非常好的解释，直接摘抄下来：</p>
<blockquote>
<p>Think of an inductive datatype <span class="math inline">\(T\)</span>
as a kind of algebraic structure: constructors are the operations which
take elements of <span class="math inline">\(T\)</span> as arguments and
produce new elements of <span class="math inline">\(T\)</span>. This is
very similar to ordinary algebra: addition takes two numbers and
produces a number.</p>
<p>In algebra it is customary that an operation takes a finite number of
arguments, and in most cases it takes zero (constant), one (unary) or
two (binary) arguments. It is convenient to generalize this for
constructors of datatypes. Suppose <code>c</code> is a constructor for a
datatype <code>T</code>:</p>
<ul>
<li>if <code>c</code> is a constant we can think of it as a function
<code>unit -&gt; T</code>, or equivalently
<code>(empty -&gt; T) -&gt; T</code>,</li>
<li>if <code>c</code> is unary we can think of it as a function
<code>T -&gt; T</code>, or equivalently
<code>(unit -&gt; T) -&gt; T</code>,</li>
<li>if <code>c</code> is binary we can think of it as a function
<code>T -&gt; T -&gt; T</code>, or equivalently
<code>T * T -&gt; T</code>, or equivalently
<code>(bool -&gt; T) -&gt; T</code>,</li>
<li>if we wanted a constructor <code>c</code> which takes seven
arguments, we could view it as a function
<code>(seven -&gt; T) -&gt; T</code> where seven is some previously
defined type with seven elements.</li>
<li>we can also have a constructor <code>c</code> which takes countably
infinitely many arguments, that would be a function
<code>(nat -&gt; T) -&gt; T</code>.</li>
</ul>
<p>These examples show that the general form of a constructor should
be</p>
<pre><code>c : (A -&gt; T) -&gt; T</code></pre>
<p>where we call <code>A</code> the arity of <code>c</code> and we think
of <code>c</code> as a constructor that takes A-many arguments of type
<span class="math inline">\(T\)</span> to produce an element of <span
class="math inline">\(T\)</span>.</p>
<p>Here is something very important: the arities must be defined before
we define <span class="math inline">\(T\)</span>, or else we cannot tell
what the constructors are supposed to be doing. If someone tries to have
an constructor</p>
<pre><code>broken: (T -&gt; T) -&gt; T</code></pre>
<p>then the question “how many arguments does broken take?” has no good
answer. You might try to answer it with “it takes T-many arguments”, but
that will not do, because <span class="math inline">\(T\)</span> is not
defined yet. We might try to get out of the cunundrum by using fancy
fixed-point theory to find a type <span class="math inline">\(T\)</span>
and an injective function <code>(T -&gt; T) -&gt; T</code>, and would
succeed, but we would also break the induction principle for <span
class="math inline">\(T\)</span> along the way. So, it’s just a bad idea
to try such a thing.</p>
</blockquote>
<h2 id="induction-principle">Induction Principle</h2>
<p>这个对应于 <mark><strong><em>Elimination
Rule</em></strong></mark>，其形式由 <mark><strong><em>Introduction
Rules</em></strong></mark> (Constructors) 决定； 其归约行为则由
<mark><strong><em>Computation Rule</em></strong></mark> 定义</p>
<p><mark>具体来说，Inductive Type (Family) 的 Introduction Rules
决定了这个类型的某种内部结构：一个 term 怎么由这个 type (family) 的其他
term 构建而成；而 Elimination Rule 则将这个 type (family) 映射到另外一个
type family 上，并且保持同样的结构</mark></p>
<p>下面用一些例子说明</p>
<h3 id="natrual-number">Natrual Number</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> ℕ <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    Z <span class="ot">:</span> ℕ</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    S <span class="ot">:</span> ℕ <span class="ot">→</span> ℕ</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>ℕ-ind <span class="ot">:</span> <span class="ot">(</span>P <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">→</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        P Z <span class="ot">→</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="ot">((</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> P n <span class="ot">→</span> P <span class="ot">(</span>S n<span class="ot">))</span> <span class="ot">→</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">---</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> P n</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>ℕ-ind p pz ps Z <span class="ot">=</span> pz</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>ℕ-ind p pz ps <span class="ot">(</span>S n<span class="ot">)</span> <span class="ot">=</span> ps n <span class="ot">(</span>ℕ-ind p pz ps n<span class="ot">)</span></span></code></pre></div>
<p><img src="nat-ind.excalidraw.png" /></p>
<p>首先整个 induction principle 的结论是 “对所有
<code>n : ℕ</code>，<code>P n</code> 都成立（inhabited）”：</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> P n</span></code></pre></div>
<p><em>（ <code>P</code> 是 indexed by <code>ℕ</code> 的类型族，属于
<code>ℕ → Set</code> ）</em></p>
<p><mark>也就是对于每一个 <code>n : ℕ</code>，我们都需要提供一个类型为
<code>P n</code> 的 term</mark>；由于 <code>ℕ</code>
有两种已知的构造方法：</p>
<ul>
<li><code>Z : ℕ</code></li>
<li><code>S n : ℕ</code></li>
</ul>
<p>故要提供两种构造 <code>P</code> 的方法：</p>
<ul>
<li><code>P Z</code></li>
<li><code>P (S n)</code></li>
</ul>
<p><code>Z</code> 没有任何参数，所以需要直接提供</p>
<pre><code>pz : P Z</code></pre>
<p>而 <code>S n</code> 是从 <code>n</code> 构造而来，且 <code>n</code>
也属于当前定义的类型
<code>ℕ</code>，为保持<mark>同样结构</mark>需要提供形如
<code>... → P n → P (S n)</code> 的函数，加上所需的参数 <code>n</code>
最终就是：</p>
<pre><code>ps : (n : ℕ) → P n → P (S n)</code></pre>
<p>那么 <code>P n</code> 从哪里来呢？<mark>递归</mark>；就是第二条
<em>Computation Rule</em></p>
<pre><code>ℕ-ind p pz ps (S n) = ps n (ℕ-ind p pz ps n)</code></pre>
<p>即计算 <code>P (S n)</code> 时，<code>P n</code> 由
<code>(ℕ-ind p pz ps n)</code> 递归得出</p>
<h3 id="fin">Fin</h3>
<p>Finite set 是带有 index 的 type family</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Fin <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    FZ <span class="ot">:</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> Fin <span class="ot">(</span>S n<span class="ot">)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    FS <span class="ot">:</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> Fin n <span class="ot">→</span> Fin <span class="ot">(</span>S n<span class="ot">)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>Fin-ind <span class="ot">:</span> <span class="ot">(</span>P <span class="ot">:</span> <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> Fin n <span class="ot">→</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">→</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>          <span class="ot">((</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> P <span class="ot">(</span>S n<span class="ot">)</span> <span class="ot">(</span>FZ n<span class="ot">))</span> <span class="ot">→</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>          <span class="ot">((</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>f <span class="ot">:</span> Fin n<span class="ot">)</span> <span class="ot">→</span> P n f <span class="ot">→</span> P <span class="ot">(</span>S n<span class="ot">)</span> <span class="ot">(</span>FS n f<span class="ot">))</span> <span class="ot">→</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>          <span class="co">---</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>          <span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>f <span class="ot">:</span> Fin n<span class="ot">)</span> <span class="ot">→</span> P n f</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>Fin-ind p pz ps <span class="ot">.(</span>S n<span class="ot">)</span> <span class="ot">(</span>FZ n<span class="ot">)</span> <span class="ot">=</span> pz n</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>Fin-ind p pz ps <span class="ot">.(</span>S n<span class="ot">)</span> <span class="ot">(</span>FS n f<span class="ot">)</span> <span class="ot">=</span> ps n f <span class="ot">(</span>Fin-ind p pz ps n f<span class="ot">)</span></span></code></pre></div>
<p><img src="fin-ind.excalidraw.png" /></p>
<p>整个 induction principle 的结论是 “对所有的
<code>f : Fin n</code>，<code>P f</code> 都成立（inhabited）”，又因
<code>Fin n</code> 本身 indexed by <code>n : ℕ</code>，所以是：</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>f <span class="ot">:</span> Fin n<span class="ot">)</span> <span class="ot">→</span> P n f</span></code></pre></div>
<p><em>（ <code>P</code> 是 indexed by 两个参数的类型族
<code>(n : ℕ) → Fin n → Set</code> ）</em></p>
<p><mark>也就是对于每一个
<code>f : Fin n</code>，我们都需要提供一个类型为 <code>P n f</code> 的
term</mark>；同样地已知两种构造方法：</p>
<ul>
<li><code>FZ n : Fin (S n)</code></li>
<li><code>FS n f : Fin (S n)</code></li>
</ul>
<p>故要提供两种构造 <code>P</code> 的方法：<a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<ul>
<li><code>P (S n) (FZ n)</code></li>
<li><code>P (S n) (FS n f)</code></li>
</ul>
<p>第一个子句处理 <code>FZ n</code> 的情况，应当形如
<code>... → P (S n) (FZ n)</code>，由于 <code>FZ</code> 是非 recursive
的，所以只要补上缺少的参数 <code>n</code> 即可：</p>
<pre><code>pz : (n : ℕ) → P (S n) (FZ n)</code></pre>
<p>第二个子句处理 <code>FS n f</code> 的情况，由于
<code>FS n f : Fin (S n)</code> 由 <code>f : Fin n</code>
构造而来，为保持<mark>相同结构</mark>应当提供
<code>... → P n f → P (S n) (FS n f)</code>，补上缺少的参数
<code>n</code> 和 <code>f</code> 得到：</p>
<pre><code>ps : (n : ℕ) → (f : Fin n) → P n f → P (S n) (FS n f)</code></pre>
<h3 id="id">Id</h3>
<p>Identity type （fix 一边的版本）是带一个 parameter 和一个 index 的
type family</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Id <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">:</span> A <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    refl <span class="ot">:</span> Id a a</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>Id-ind <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">(</span>P <span class="ot">:</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> Id a x <span class="ot">→</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">→</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>         P a refl <span class="ot">→</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>         <span class="co">---</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>         <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>e <span class="ot">:</span> Id a x<span class="ot">)</span> <span class="ot">→</span> P x e</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>Id-ind a p r <span class="ot">.</span>a refl <span class="ot">=</span> r</span></code></pre></div>
<p>parameter 由于是一致的，所以在 induction principle
里被提取到最前面去</p>
<p>整个 induction principle 的结论是 “对所有的
<code>e : Id a x</code>，<code>P e</code> 都成立（inhabited）”，又因
<code>Id a x</code> 本身 indexed by <code>x : A</code>，所以是：</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>e <span class="ot">:</span> Id a x<span class="ot">)</span> <span class="ot">→</span> P x e</span></code></pre></div>
<p><em>（ <code>P</code> 的类型是 <code>(x : A) → Id a x → Set</code>
）</em></p>
<p>只有一个构造方法 <code>refl : Id a a</code>，故只需要提供
<code>P a refl</code></p>
<h3 id="t">T</h3>
<p>再来一个依赖于 countably infinite 个其他 term 的</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> T <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    T0 <span class="ot">:</span> T</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    T1 <span class="ot">:</span> <span class="ot">(</span>ℕ <span class="ot">→</span> T<span class="ot">)</span> <span class="ot">→</span> T</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>T-ind <span class="ot">:</span> <span class="ot">(</span>P <span class="ot">:</span> T <span class="ot">→</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">→</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        P T0 <span class="ot">→</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="ot">((</span>f <span class="ot">:</span> ℕ <span class="ot">→</span> T<span class="ot">)</span> <span class="ot">→</span> <span class="ot">((</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> P <span class="ot">(</span>f n<span class="ot">))</span> <span class="ot">→</span> P <span class="ot">(</span>T1 f<span class="ot">))</span> <span class="ot">→</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">---</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="ot">(</span>t <span class="ot">:</span> T<span class="ot">)</span> <span class="ot">→</span> P t</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>T-ind p t0 t1 T0 <span class="ot">=</span> t0</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>T-ind p t0 t1 <span class="ot">(</span>T1 f<span class="ot">)</span> <span class="ot">=</span> t1 f <span class="ot">(λ(</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> T-ind p t0 t1 <span class="ot">(</span>f n<span class="ot">))</span></span></code></pre></div>
<p>主要看第二个子句：由于 <code>T1 f : T</code> 由
<code>f 0 : T</code>/<code>f 1 : T</code>/… 构造而得</p>
<p>故 <code>P (T1 f)</code> 应当可使用参数
<code>P (f 0)</code>/<code>P (f 1)</code>/…，即
<code>(n : ℕ) → P (f n)</code>，应当提供形如
<code>... → ((n : ℕ) → P (f n)) → P (T1 f)</code>， 补上参数
<code>f</code> 得：</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode agda"><code class="sourceCode agda"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>t1 <span class="ot">:</span> <span class="ot">(</span>f <span class="ot">:</span> ℕ <span class="ot">→</span> T<span class="ot">)</span> <span class="ot">→</span> <span class="ot">((</span>n <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> P <span class="ot">(</span>f n<span class="ot">))</span> <span class="ot">→</span> P <span class="ot">(</span>T1 f<span class="ot">)</span></span></code></pre></div>
<h3 id="coq-equivalent">Coq equivalent</h3>
<p>这里用 Agda 是因为比较喜欢它的语法，但它不会自动生成 induction
principle，所以用Coq 的 <code>Check xxx_ind</code> 检查一遍 <a
href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a></p>
<h2 id="term-in-type">Term in Type</h2>
<p>(updated @ 2024)</p>
<p>补充一个问题，一个类型里的元素是不是仅仅就是那些由 constructor
构造出来的呢？按我目前的理解是未必，因为上述只是<mark>形式上</mark>的规则而已，
存在着满足这些规则的不同的模型，有些模型可能有一些无法直接由 constructor
构造出来的元素，例如：<a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a> <a href="#fn8" class="footnote-ref"
id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<blockquote>
<p>just like in order to define a group homomorphism out of the free
group on one generator you only need to say what happens to the
generator. It doesn’t mean that every element of the group is the
generator</p>
</blockquote>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://agda.readthedocs.io/en/v2.6.0.1/language/data-types.html#id2"
class="uri">https://agda.readthedocs.io/en/v2.6.0.1/language/data-types.html#id2</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>类型 <code>Pᵧ</code> 有可能依赖
<code>pₓ</code>（<code>x &lt; y</code>）<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>类型 <code>Iᵧ</code> 有可能依赖
<code>iₓ</code>（<code>x &lt; y</code>）以及所有的 <code>pₙ</code><a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a
href="https://agda.readthedocs.io/en/v2.6.0.1/language/data-types.html#strict-positivity"
class="uri">https://agda.readthedocs.io/en/v2.6.0.1/language/data-types.html#strict-positivity</a><a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>注意这里没有 <code>P Z f</code>，因为 <code>Fin Z</code>
是空的<a href="#fnref5" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><pre class="coq"><code>Inductive N : Type :=
| Z : N
| S : N -&gt; N
.

Check N_ind.
(*
N_ind :
  forall P : N -&gt; Prop,
  P Z -&gt;
  (forall n : N, P n -&gt; P (S n)) -&gt;
  forall n : N, P n
*)

Inductive Fin : N -&gt; Type :=
| FZ : forall n : N, Fin (S n)
| FS : forall n : N, Fin n -&gt; Fin (S n)
.

Check Fin_ind.
(*
Fin_ind :
  forall P : forall n : N, Fin n -&gt; Prop,
  (forall n : N, P (S n) (FZ n)) -&gt;
  (forall (n : N) (f0 : Fin n), P n f0 -&gt; P (S n) (FS n f0)) -&gt;
  forall (n : N) (f1 : Fin n), P n f1
*)

Inductive Id {A : Type} (a : A) : A -&gt; Type :=
| refl : Id a a
.

Check Id_ind.
(*
Id_ind :
  forall (A : Type) (a : A) (P : forall a0 : A, Id a a0 -&gt; Prop),
  P a (refl a) -&gt;
  forall (y : A) (i : Id a y), P y i
*)

Inductive T : Type :=
| T0 : T
| T1 : (N -&gt; T) -&gt; T
.

Check T_ind.
(*
T_ind :
  forall P : T -&gt; Prop,
  P T0 -&gt;
  (forall t : N -&gt; T, (forall n : N, P (t n)) -&gt; P (T1 t)) -&gt;
  forall t : T, P t
*)</code></pre>
<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn7"><p><a
href="https://math.stackexchange.com/questions/4950274/how-to-interpret-the-induction-principle-of-identity-type-j-rule"
class="uri">https://math.stackexchange.com/questions/4950274/how-to-interpret-the-induction-principle-of-identity-type-j-rule</a><a
href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p><a
href="https://github.com/HoTT/book/issues/460#issuecomment-23364295"
class="uri">https://github.com/HoTT/book/issues/460#issuecomment-23364295</a><a
href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<link rel="stylesheet" href="/assets/venobox/dist/venobox.min.css" />
<script src="/assets/venobox/dist/venobox.min.js"></script>
<script>
  document.querySelectorAll('img').forEach((img) => {
    const a = document.createElement("a")
    a.href = '#'
    a.setAttribute('data-href', img.src)
    a.classList.add('images')
    img.replaceWith(a)
    a.appendChild(img)
  })
  new VenoBox({
    selector: '.images',
    fitView: true,
  });
</script>
</body>
</html>
