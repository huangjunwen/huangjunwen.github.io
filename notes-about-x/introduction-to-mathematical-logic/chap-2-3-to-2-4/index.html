<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="HJW" />
  <meta name="dcterms.date" content="2022-02-28" />
  <title>Chapter 2: First-Order Logic and Model Theory (2.3~2.4)</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <!-- latex css begin -->
  <!--<link href="/assets/latex.css/style.min.css" rel="stylesheet" />-->
  <link href="../../../assets/latex.css/style.css" rel="stylesheet" />
  <style>
  /* fixes for latex.css */
  .date {
    text-align: center;
  }

  div.sourceCode {
    background: var(--pre-bg-color);
    border-radius: 10px;
  }

  dl dd {
    text-align: left;
  }

  #footnotes {
    margin-top: 1em;
  }

  #footnotes hr:first-child {
    display: none;
  }
  </style>
  <!-- latex css end -->

  <!-- venobox begin -->
  <link rel="stylesheet" href="../../../assets/venobox/dist/venobox.min.css" />
  <script src="../../../assets/venobox/dist/venobox.min.js"></script>
  <script>
    window.addEventListener("load", (ev) => {
      document.querySelectorAll('img').forEach((img) => {
        const a = document.createElement("a")
        a.href = '#'
        a.setAttribute('data-href', img.src)
        a.classList.add('images')
        img.replaceWith(a)
        a.appendChild(img)
      })
      new VenoBox({
        selector: '.images',
        fitView: true,
      })
    })
  </script>
  <!-- venobox end -->

  <!-- layout begin -->
  <style>
  #sidebar {
    position: fixed;
    top: 0;
    left: 0;
    z-index: 999;
    max-width: 400px;
    width: 80%;
    height: 100%;
    padding: 2rem;
    background-color: #eee;
    box-shadow: 0 10px 20px -4px #000;
    overflow-x: hidden;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #ccc #eee;
    scrollbar-gutter: stable;
    pointer-events: none;
    opacity: 0;
    visibility: hidden;
    transform: translateX(-100%);
    transition: opacity 0.3s ease, visibility 0.2s ease, transform 0.3s ease;
  }
  #sidebar.show {
    pointer-events: all;
    opacity: 1;
    visibility: visible;
    transform: translateX(0);
  }
  #sidebar_toggler {
    position: fixed;
    top: 4vh;
    right: 3vw;
    z-index: 1000;
    width: 2.8rem;
    height: 2.4rem;
    padding: 0.5rem;
    border: solid #999 0.1rem;
    border-radius: 0.4rem;
    background-color: #fff;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    cursor: pointer;
    overflow: hidden;
  }

  #sidebar_toggler span {
    background-color: #999;
    width: 100%;
    height: 0.2rem;
    transition: all 0.3s ease;
    pointer-events: none;
  }
  nav span {
    display: inline-block;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    /*white-space: pre-wrap;*/
    width: 90%;
  }
  nav li:before {
    content: '';
  }
  nav span:before {
    content: "\25CF";
    margin-right: 8px;
  }
  nav .caret {
    cursor: pointer;
    user-select: none; /* Prevent text selection */
  }
  nav .caret::before {
    content: "\25B6";
    color: black;
    display: inline-block;
    margin-right: 6px;
  }
  nav .caret-down::before {
    transform: rotate(90deg);
  }
  nav .collapse {
    display: none;
  }
  nav .bold {
    font-weight: bold;
  }
  </style>
  <script>
    window.addEventListener("load", (ev) => {
      /* setup sidebar */
      // https://www.cssscript.com/demo/responsive-sidebar-nav-hamburger/
      const sidebar = document.querySelector('#sidebar')
      const sidebarToggler = document.querySelector('#sidebar_toggler')

      sidebarToggler.addEventListener('click', () => {
        sidebar.classList.toggle('show')
      });

      const keywords = document.querySelector('meta[name="keywords"]')
      if (keywords && keywords.content.includes('showSidebar')) {
        sidebar.classList.add('show')
      }

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          sidebar.classList.remove('show')
        }
      })

      window.addEventListener('click', (e) => {
        if (!sidebar.contains(e.target) && !sidebarToggler.contains(e.target)) {
          sidebar.classList.remove('show')
        }
      });

      /* load urls */
      const root2PageDir = "/notes-about-x/introduction-to-mathematical-logic/chap-2-3-to-2-4"
      const page2RootDir = "../../.."
      const sideNavLinks = document.querySelector('#side_navlinks');
      function buildSideLink(li, node) {
        // span contains the text and link (if provided)
        const span = li.appendChild(document.createElement("span"))
        if (node.url) {
          const a = span.appendChild(document.createElement("a"))
          a.href = page2RootDir + node.url
          a.textContent = node.text
        } else {
          span.textContent = node.text
        }
        span.setAttribute("title", node.text)
        if ((root2PageDir + "/").startsWith(node.path + "/")) {
          span.classList.add("bold")
        }

        if (node.children.length > 0) {
          // if has children, then add caret and append a nested <ul> for children
          span.classList.add("caret")
          const ul = li.appendChild(document.createElement("ul"))
          ul.classList.add("nested")
          // do not collapse current path
          if ((root2PageDir + "/").startsWith(node.path + "/")) {
            span.classList.add("caret-down")
          } else {
            ul.classList.add("collapse")
          }
          node.children.forEach((child) => {
            const l = ul.appendChild(document.createElement("li"))
            buildSideLink(l, child)
          })
        }
      }
      async function loadSideLinks() {
        const resp = await fetch("../../../urls.json")
        const data = await resp.json()
        // console.log(data)
        const root = sideNavLinks.appendChild(document.createElement("ul"))
        data.children.forEach((child) => {
          buildSideLink(root.appendChild(document.createElement("li")), child)
        })

        const toggler = root.getElementsByClassName("caret")
        for (let i=0; i<toggler.length; i++) {
          toggler[i].addEventListener("click", function () {
            this.parentElement.querySelector(".nested").classList.toggle("collapse")
            this.classList.toggle("caret-down")
            return false
          })
        }
      }
      loadSideLinks()
    })
  </script>
  <!-- layout end -->
  <script
  src="../../../assets/mathjax/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<!-- sidebar begin -->
<aside id="sidebar">
  <div class="sidebar_content sidebar_head">
    <h1>Content</h1>
  </div>
  <div class="sidebar_content sidebar_body">
    <nav id="side_navlinks" class="side_navlinks">
      <!--<ul>
        <li><a href="#">Home</a></li>
        <li><a href="#">About</a></li>
        <li><a href="#">Services</a></li>
        <li><a href="#">Portfolio</a></li>
        <li><a href="#">Contact</a></li>
      </ul>-->
    </nav>
  </div>
</aside>
<div id="sidebar_toggler">
  <span></span>
  <span></span>
  <span></span>
</div>
<!-- sidebar end -->

<!--main article begin-->
<article>
<header id="title-block-header">
<h1 class="title">Chapter 2: First-Order Logic and Model Theory
(2.3~2.4)</h1>
<p class="author">HJW</p>
<p class="date">2022-02-28</p>
</header>
<h2 id="first-order-theories">2.3 First-Order Theories</h2>
<p>一阶理论：一个一阶理论 <span
class="math inline">\(\mathcal{K}\)</span>
使用一个一阶语言的符号及其公式，以及如下这些公理（公理分两种：
逻辑公理和非逻辑公理）以及演绎规则</p>
<h3 id="logical-axioms">2.3.1 Logical Axioms</h3>
<dl>
<dt>逻辑公理</dt>
<dd>
<p>如果 <span class="math inline">\(B\)</span>，<span
class="math inline">\(C\)</span>，<span class="math inline">\(D\)</span>
都是合式公式，则如下是 <span class="math inline">\(\mathcal{K}\)</span>
的逻辑公理</p>
<ul>
<li><span id="A1">A1:</span> <span class="math inline">\(B \Rightarrow
(C \Rightarrow B)\)</span></li>
<li><span id="A2">A2:</span> <span class="math inline">\((B \Rightarrow
(C \Rightarrow D)) \Rightarrow ((B \Rightarrow C) \Rightarrow (B
\Rightarrow D))\)</span></li>
<li><span id="A3">A3:</span> <span class="math inline">\((\neg C
\Rightarrow \neg B) \Rightarrow ((\neg C \Rightarrow B) \Rightarrow
C)\)</span></li>
<li><span id="A4">A4:</span> 如果 <span
class="math inline">\(B(x_i)\)</span> 是一个合式公式，且项 <span
class="math inline">\(t\)</span> 可以自由替换 <span
class="math inline">\(x_i\)</span> 则 <span
class="math inline">\((\forall x_i)B(x_i) \Rightarrow B(t)\)</span>
（特别地，<span class="math inline">\(t\)</span> 可以是 <span
class="math inline">\(x_i\)</span>，于是总有 <span
class="math inline">\((\forall x_i)B \Rightarrow B\)</span>）</li>
<li><span id="A5">A5:</span> 如果 <span class="math inline">\(B\)</span>
不包含 <span class="math inline">\(x_i\)</span> 的自由变量，则 <span
class="math inline">\((\forall x_i)(B \Rightarrow C) \Rightarrow (B
\Rightarrow (\forall x_i)C)\)</span></li>
</ul>
</dd>
</dl>
<h3 id="proper-axioms">2.3.2 Proper Axioms</h3>
<p>每一个理论都有可能有其他的非逻辑公理，也可能完全没有，如果没有的话则称为<strong>一阶谓词演算</strong>（first-order
predicate calculus）</p>
<h3 id="rules-of-inference">2.3.3 Rules of Inference</h3>
<p>演绎规则有两个</p>
<ol type="1">
<li>Modus ponens（缩写为 MP)：<span class="math inline">\(B\)</span> 和
<span class="math inline">\(B \Rightarrow C\)</span> 推出 <span
class="math inline">\(C\)</span></li>
<li>Generalization（缩写为 Gen)：<span class="math inline">\(B\)</span>
推出 <span class="math inline">\((\forall x_i)B\)</span></li>
</ol>
<p>注意到根据 2.2 的 <a href="../chap-2-1-to-2-2/#property-3">Property
3</a> 和 <a href="../chap-2-1-to-2-2/#property-6">Property 6</a>，
在一个解释下，如果对为真的式子运用 MP 和 Gen 仍然会得出为真的式子</p>
<p>一些一阶理论的例子</p>
<ol type="1">
<li>Partial order：该理论使用的语言只有一个谓词符号 <span
class="math inline">\(A_1^2(x_i, x_j)\)</span> 写作 <span
class="math inline">\(x_i &lt; x_j\)</span>，并且有两个非逻辑公理
<ol type="1">
<li><span class="math inline">\((\forall x_1)(\neg x_1 &lt;
x_1)\)</span> （irreflexivity）</li>
<li><span class="math inline">\((\forall x_1)(\forall x_2)(\forall
x_3)(x_1 &lt; x_2 \wedge x_2 &lt; x_3 \Rightarrow x_1 &lt; x_3)\)</span>
（transitivity）</li>
</ol></li>
<li>Group theory：该理论使用语言有一个谓词符号 <span
class="math inline">\(A_1^2(t, s)\)</span> 写作 <span
class="math inline">\(t = s\)</span>，一个函数符号 <span
class="math inline">\(f_1^2(t, s)\)</span> 写作 <span
class="math inline">\(t + s\)</span>， 一个常量符号 <span
class="math inline">\(a_1\)</span> 写作 0，并且有以下非逻辑公理
<ol type="1">
<li><span class="math inline">\((\forall x_1)(\forall x_2)(\forall
x_3)(x_1 + (x_2 + x_3) = (x_1 + x_2) + x_3)\)</span>
（associativity）</li>
<li><span class="math inline">\((\forall x_1)(0 + x_1 = x_1)\)</span>
（identiy）</li>
<li><span class="math inline">\((\forall x_1)(\exists x_2)(x_2 + x_1 =
0)\)</span> （inverse）</li>
<li><span class="math inline">\((\forall x_1)(x_1 = x_1)\)</span>
（reflexivity of =）</li>
<li><span class="math inline">\((\forall x_1)(\forall x_2)(x_1 = x_2
\Rightarrow x_2 = x_1)\)</span> （symmetry of =）</li>
<li><span class="math inline">\((\forall x_1)(\forall x_2)(\forall
x_3)(x_1 = x_2 \wedge x_2 = x_3 \Rightarrow x_1 = x_3)\)</span>
（transitivity of =）</li>
<li><span class="math inline">\((\forall x_1)(\forall x_2)(\forall
x_3)(x_2 = x_3 \Rightarrow x_1 + x_2 = x_1 + x_3 \wedge x_2 + x_1 = x_3
+ x_1)\)</span> （substitutivity of =）</li>
</ol></li>
</ol>
<h2 id="properties-of-first-order-theories">2.4 Properties of
First-Order Theories</h2>
<h3 id="proposition-2.1">Proposition 2.1</h3>
<blockquote>
<p><span class="math inline">\(\mathcal{K}\)</span> 中的重言式 <span
class="math inline">\(B\)</span> 也是 <span
class="math inline">\(\mathcal{K}\)</span> 的定理，且其证明只需要公理
A1~A3 和 MP</p>
</blockquote>
<div class="proof">
<p><span class="math inline">\(B\)</span> 是由一个 <span
class="math inline">\(\mathcal{L}\)</span> 中的重言式 <span
class="math inline">\(B_{\mathcal{L}}\)</span> 替换其 statement letters
为特定 wf 所得的， 由 <a
href="../chap-1-4/#proposition-1.14-completeness-theorem">Proposition
1.14</a> 存在一个 <span class="math inline">\(\mathcal{L}\)</span>
中的证明， 将该证明中这些 statement letters 替换为其对应
wf（如果证明里出现其他没有出现在 <span
class="math inline">\(B_{\mathcal{L}}\)</span> 中的 statement letters
则替换为任意 wf）即可得到一个 <span
class="math inline">\(\mathcal{K}\)</span> 中 <span
class="math inline">\(B\)</span> 的证明，且只用到 A1~A3 和 MP</p>
</div>
<h3 id="proposition-2.2">Proposition 2.2</h3>
<blockquote>
<p>一阶谓词演算（没有非逻辑公理）的定理在所有解释下都是真的（逻辑有效
logically valid）</p>
</blockquote>
<div class="proof">
<p>由 <a href="../chap-2-1-to-2-2/#property-7">Property 7</a> 公理 A1~A3
是逻辑有效的，由 <a href="../chap-2-1-to-2-2/#property-10">Property
10</a> 公理 A4 是逻辑有效的，由 <a
href="../chap-2-1-to-2-2/#property-11">Property 11</a> 公理 A5
逻辑有效，又由 <a href="../chap-2-1-to-2-2/#property-3">Property 3</a>
和 <a href="../chap-2-1-to-2-2/#property-6">Property 6</a> 易知 MP 和
Gen 这两个规则都能延续逻辑有效的性质，故所有定理均是逻辑有效的</p>
</div>
<h3 id="corollary-2.3">Corollary 2.3</h3>
<blockquote>
<p><a href="#proper-axioms">一阶谓词演算</a>是一致的（<span
class="math inline">\(B\)</span> 和 <span class="math inline">\(\neg
B\)</span> 不能同时有证明）</p>
</blockquote>
<div class="proof">
<p>如果 <span class="math inline">\(B\)</span> 和 <span
class="math inline">\(\neg B\)</span> 都是定理（有证明, e.g. <span
class="math inline">\(\vdash\)</span>），由 Proposition 2.2
则两者都是逻辑有效的（e.g. <span
class="math inline">\(\vDash\)</span>），这是不可能的， 因为任意解释下
<span class="math inline">\(B\)</span> 和 <span
class="math inline">\(\neg B\)</span> 不能同时为真</p>
<p>实际上，假如 <span class="math inline">\(B\)</span> 和 <span
class="math inline">\(\neg B\)</span> 同时有证明，则根据爆炸原理 <span
class="math inline">\(B \Rightarrow (\neg B \Rightarrow
C)\)</span>（一个重言式，根据 Proposition 2.1 则也是定理），则会导致任意
<span class="math inline">\(C\)</span>
都可以证明；这又能推导出，假如有任意公式不是定理的话，则 <span
class="math inline">\(\mathcal{K}\)</span> 一致</p>
</div>
<h3 id="演绎定理的一些前置说明"><em>演绎定理的一些前置说明</em></h3>
<p>命题演算里的演绎定理没办法原封不动地移植到一阶理论中，例如 <span
class="math inline">\(B \vdash_{\mathcal{K}} (\forall x_i)B\)</span>
总是成立（Gen）， 但 <span class="math inline">\(\vdash_{\mathcal{K}} B
\Rightarrow (\forall x_i)B\)</span> 却不一定成立（相当意外的）：例如
<span class="math inline">\(x_1 = 0 \Rightarrow (\forall x_1)x_1 =
0\)</span> <a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>，当 <span class="math inline">\(x_1
= 0\)</span> 时不成立，故其不是逻辑有效，由 Proposition 2.2
知不可能是定理</p>
<p>一个有修改但依然有用的演绎定理是可以推导出来的，不过首先要一些额外的定义</p>
<dl>
<dt>Depend upon</dt>
<dd>
<p>令 <span class="math inline">\(\Gamma\)</span>
是一个合式公式集，合式公式 <span class="math inline">\(B \in
\Gamma\)</span>，又 <span class="math inline">\(D_1, D_2, ...,
D_n\)</span> 是从 <span class="math inline">\(\Gamma\)</span>
推导出的一个证明； 称 <span class="math inline">\(D_i\)</span>
依赖于（depend upon）<span class="math inline">\(B\)</span>
当且仅当：</p>
<ol type="1">
<li><span class="math inline">\(D_i\)</span> 就是 <span
class="math inline">\(B\)</span>，或者</li>
<li><span class="math inline">\(D_i\)</span> 是一些前面的公式用 MP 或
Gen 产生的直接结果，而这些前面的公式中至少有一个是依赖于 <span
class="math inline">\(B\)</span> 的</li>
</ol>
</dd>
</dl>
<h3 id="proposition-2.4">Proposition 2.4</h3>
<blockquote>
<p>假如 <span class="math inline">\(C\)</span> 在 <span
class="math inline">\(\Gamma, B \vdash C\)</span> 的一个证明中不依赖于
<span class="math inline">\(B\)</span>，则有 <span
class="math inline">\(\Gamma \vdash C\)</span></p>
</blockquote>
<div class="proof">
<p>直觉可知从 <span class="math inline">\(C\)</span> 开始往前上溯（MP
时上溯两个源头，Gen 则上溯一个源头，其他的停止）一直到证明的开始，
所经过的公式不可能有 <span
class="math inline">\(B\)</span>，这些经过的公式就构成了 <span
class="math inline">\(\Gamma \vdash C\)</span>
的证明（亦即是原来证明的的一个子集）</p>
<p>书里用归纳法证明：</p>
<p>设 <span class="math inline">\(\Gamma, B \vdash C\)</span>
的一个证明序列是 <span class="math inline">\(D_1, D_2, ...,
D_n\)</span>（其中 <span class="math inline">\(D_n\)</span> 就是 <span
class="math inline">\(C\)</span> 了），且 <span
class="math inline">\(C\)</span> 不依赖于 <span
class="math inline">\(B\)</span>； 归纳假设 <span
class="math inline">\(i &lt; n\)</span> 时，若 <span
class="math inline">\(D_i\)</span> 不依赖于 <span
class="math inline">\(B\)</span>，则 <span class="math inline">\(\Gamma
\vdash D_i\)</span>；现在考虑 <span
class="math inline">\(D_n\)</span>，若 <span class="math inline">\(D_n
\in \Gamma\)</span> 或者是一个公理，则直接得出 <span
class="math inline">\(\Gamma \vdash D_n\)</span>，若是由前面的一条公式
Gen 或 前面两条公式 MP 所得，由于 <span
class="math inline">\(D_n\)</span> 不依赖于 <span
class="math inline">\(B\)</span>，那之前的这一条或两条公式也不依赖于
<span class="math inline">\(B\)</span>，用归纳假设就得出它们可以仅由
<span class="math inline">\(\Gamma\)</span> 推出，因此 <span
class="math inline">\(D_n\)</span> 也就可以仅由 <span
class="math inline">\(\Gamma\)</span> 推出了</p>
</div>
<h3 id="proposition-2.5-deduction-theorem">Proposition 2.5 (Deduction
Theorem)</h3>
<p>（拗口的）演绎定理</p>
<blockquote>
<p>假设在 <span class="math inline">\(\Gamma, B \vdash C\)</span>
的证明序列（步骤） <span class="math inline">\(D_1, D_2, ...,
D_n\)</span> 里，不存在 Gen 某个公式的步骤且该公式依赖于 <span
class="math inline">\(B\)</span> 且添加的量词变量是 <span
class="math inline">\(B\)</span> 的自由变量，则 <span
class="math inline">\(\Gamma \vdash B \Rightarrow C\)</span></p>
</blockquote>
<div class="proof">
<p><img src="deduction-theorem.png" /></p>
<p>如上图，基本上跟命题逻辑里的演绎定理证明过程是一样的，只是多了 Gen
的分支情况（虚线框内）</p>
</div>
<p>不过这个演绎定理里的条件太过拗口冗长，下面这些弱一些的推论可能在实际中更有用</p>
<h3 id="corollary-2.6">Corollary 2.6</h3>
<blockquote>
<p>如果 <span class="math inline">\(\Gamma, B \vdash C\)</span>
的证明序列中没有涉及到添加 <span class="math inline">\(B\)</span>
的自由变量为量词的 Gen 的话，则 <span class="math inline">\(\Gamma
\vdash B \Rightarrow C\)</span></p>
</blockquote>
<h3 id="corollary-2.7">Corollary 2.7</h3>
<blockquote>
<p>如果 <span class="math inline">\(B\)</span>
是封闭公式的话（没有自由变量）且 <span class="math inline">\(\Gamma, B
\vdash C\)</span>，则 <span class="math inline">\(\Gamma \vdash B
\Rightarrow C\)</span></p>
</blockquote>
<h3 id="extension-of-propositions-2.42.7">Extension of Propositions
2.4–2.7</h3>
<p><em>（这一段有点不太好理解，直接按我自己的理解方式来说明）</em></p>
<p>演绎定理实际上是将旧证明 <span class="math inline">\(\Gamma, B \vdash
C_j\)</span> 转换为新证明 <span class="math inline">\(\Gamma \vdash B
\Rightarrow C_j\)</span> 的一个算法
（当然首先旧证明序列必须满足上述那些条件）；如下是一种具体方法</p>
<p><img src="deduction-theorem-2.png" /></p>
<p>按顺序读取旧证明的每一步 <span
class="math inline">\(C_j\)</span>，在上图左边确定 <span
class="math inline">\(C_j\)</span>
所属，然后输出对应右边的一组公式序列，
这些一组组的公式序列连接起来即组成新的证明</p>
<p>观察上图可知：</p>
<ol type="1">
<li><p>右边每一组序列的最后一个公式必定是 <span class="math inline">\(B
\Rightarrow C_j\)</span>，这正是演绎定理归纳法要证明的</p></li>
<li><p>所有不依赖于 <span class="math inline">\(B\)</span> 的 <span
class="math inline">\(C_j\)</span> 会同时出现在新旧证明中：见
<code>*</code> 或 <code>**</code> 处， 其中 <code>**</code>
处的意思是，该 <span class="math inline">\(C_j\)</span>
在本组公式序列里实际上是没有用到的，
特意补全上去就是为了保证所有不依赖于 <span
class="math inline">\(B\)</span> 的 <span
class="math inline">\(C_j\)</span> 也都出现在新证明中，
也许后续证明（例如某个 Gen）会用到</p></li>
<li><p>所有不依赖于 <span class="math inline">\(B\)</span> 的 <span
class="math inline">\(C_j\)</span>
不单止会同时出现在新旧证明，而且它们的 <span
class="math inline">\(\Gamma\)</span> 依赖集也是一样的
（因为证明过程是完全相同的）</p></li>
<li><p>旧证明 <span class="math inline">\(C_j\)</span> 与对应新证明
<span class="math inline">\(B \Rightarrow C_j\)</span> 也有相同的 <span
class="math inline">\(\Gamma\)</span> 依赖集</p>
<div class="proof">
<p>以 <span class="math inline">\(j\)</span> 进行归纳</p>
<ul>
<li>若 <span class="math inline">\(C_j\)</span> 是公理，不依赖于 <span
class="math inline">\(\Gamma\)</span> 中任何前提，对应右侧 <span
class="math inline">\(B \Rightarrow C_j\)</span> 仅由公理 MP
得出，也不依赖于 <span class="math inline">\(\Gamma\)</span>
中任何前提</li>
<li>若 <span class="math inline">\(C_j \in
\Gamma\)</span>，则依赖于自身，右侧由 <span
class="math inline">\(C_j\)</span> 和公理 MP 得出，故也依赖于 <span
class="math inline">\(C_j\)</span></li>
<li>若 <span class="math inline">\(C_j\)</span> 是 <span
class="math inline">\(B\)</span>，不依赖于 <span
class="math inline">\(\Gamma\)</span> 中任何前提，右侧是 <a
href="../chap-1-4/#lemma-1.8">Lemma 1.8</a>， 无任何依赖，自然也不依赖于
<span class="math inline">\(\Gamma\)</span> 中任何前提</li>
<li>若 <span class="math inline">\(C_j\)</span> 为 <span
class="math inline">\(C_l \Rightarrow C_j\)</span> 和 <span
class="math inline">\(C_l\)</span> MP 所得，则其 <span
class="math inline">\(\Gamma\)</span> 依赖集为这两前件依赖集的并集，
由归纳假设，该并集等于 <span class="math inline">\(B \Rightarrow (C_l
\Rightarrow C_j)\)</span>¹ 和 <span class="math inline">\(B \Rightarrow
C_l\)</span>² 依赖集的并集， 右侧恰好涉及到公式 ¹² （两个 MP），因此两侧
<span class="math inline">\(\Gamma\)</span> 依赖集相同</li>
<li>若 <span class="math inline">\(C_j\)</span> 为 <span
class="math inline">\((\forall x_i)C_l\)</span>，则其依赖集等于 <span
class="math inline">\(C_l\)</span> 的依赖集；
右侧有两种可能的输出，第一种用到 Gen <span
class="math inline">\(C_l\)</span>，由 3 知新旧证明中的 <span
class="math inline">\(C_l\)</span> 是有相同依赖集的； 第二种用到 Gen
<span class="math inline">\(B \Rightarrow C_l\)</span>，由归纳假设知左侧
<span class="math inline">\(C_l\)</span> 和右侧 <span
class="math inline">\(B \Rightarrow C_l\)</span> 也是有相同依赖集的</li>
</ul>
</div></li>
<li><p>当且仅当旧证明有 Gen 时（<span class="math inline">\((\forall
x_i)C_l\)</span>），新证明有 Gen（<span class="math inline">\((\forall
x_i)C_l\)</span> 或者 <span class="math inline">\((\forall x_i)(B
\Rightarrow C_l)\)</span>），由 3 和 4 知两边的 <span
class="math inline">\(\Gamma\)</span>
依赖集一样，且两边添加的量词变量也一样（<span
class="math inline">\(x_i\)</span>）， 因此可以得出下面的结论</p></li>
</ol>
<blockquote>
<p>如果 <span class="math inline">\(\Gamma, A, B \vdash C\)</span>
的证明满足</p>
<ul>
<li><code>a</code> 没有一个 Gen 的步骤是依赖于 <span
class="math inline">\(A\)</span> 的且其添加的量词变量是 <span
class="math inline">\(A\)</span> 的自由变量</li>
<li><code>b</code> 没有一个 Gen 的步骤是依赖于 <span
class="math inline">\(B\)</span> 的且其添加的量词变量是 <span
class="math inline">\(B\)</span> 的自由变量</li>
</ul>
<p>则可以直接 <span class="math inline">\(\Gamma \vdash A \Rightarrow (B
\Rightarrow C)\)</span></p>
</blockquote>
<div class="proof">
<p>由 <code>b</code> 和演绎定理可得新证明 <span
class="math inline">\(\Gamma, A \vdash B \Rightarrow C\)</span>，由 5 和
<code>a</code> 可知，这个新的证明也满足 <code>a</code>，
因此可以再次使用演绎定理推出 <span class="math inline">\(\Gamma \vdash A
\Rightarrow (B \Rightarrow C)\)</span></p>
</div>
<p>这个结论可以推而广之，只要原始证明对多个前提都满足条件的话，则可以一步多次演绎定理</p>
<h3 id="exercises">Exercises</h3>
<h4 id="证明以下定理">2.27 证明以下定理</h4>
<ul>
<li><p><span id="ex-2-27-a"><code>a</code></span> <span
class="math inline">\(\vdash (\forall x)(B \Rightarrow C) \Rightarrow
((\forall x)B \Rightarrow (\forall x)C)\)</span></p>
<div class="proof">
<ol type="1">
<li><span class="math inline">\((\forall x)(B \Rightarrow C)\)</span>
Hyp</li>
<li><span class="math inline">\((\forall x)(B \Rightarrow C) \Rightarrow
(B \Rightarrow C)\)</span> A4</li>
<li><span class="math inline">\(B \Rightarrow C\)</span> MP
上述两个</li>
<li><span class="math inline">\((\forall x)B\)</span> Hyp</li>
<li><span class="math inline">\((\forall x)B \Rightarrow B\)</span>
A4</li>
<li><span class="math inline">\(B\)</span> MP 上述两个</li>
<li><span class="math inline">\(C\)</span> MP 3 和 6</li>
<li><span class="math inline">\((\forall x)C\)</span> Gen</li>
</ol>
<p>上述证明了 <span class="math inline">\((\forall x)(B \Rightarrow C),
(\forall x)B \vdash (\forall x)C\)</span> 注意上述证明只有最后一步是
Gen， 且量词 <span class="math inline">\(x\)</span>
不是两个前提的自由变量，故可以使用 DT（Deduction Theorem）得出证明</p>
</div></li>
<li><p><span id="ex-2-27-b"><code>b</code></span> <span
class="math inline">\(\vdash (\forall x)(B \Rightarrow C) \Rightarrow
((\exists x)B \Rightarrow (\exists x)C)\)</span></p>
<div class="proof">
<ol type="1">
<li><span class="math inline">\((\forall x)(B \Rightarrow C)\)</span>
Hyp</li>
<li><span class="math inline">\((\forall x)(B \Rightarrow C) \Rightarrow
(B \Rightarrow C)\)</span> A4</li>
<li><span class="math inline">\(B \Rightarrow C\)</span> MP
上述两个</li>
<li><span class="math inline">\((B \Rightarrow C) \Rightarrow (\neg C
\Rightarrow \neg B)\)</span> <a href="../chap-1-4/#lemma-1.11-e">Lemma
1.11#e</a></li>
<li><span class="math inline">\(\neg C \Rightarrow \neg B\)</span> MP
上述两个</li>
<li><span class="math inline">\((\forall x)(\neg C \Rightarrow \neg
B)\)</span> Gen</li>
<li><span class="math inline">\((\forall x)(\neg C \Rightarrow \neg B)
\Rightarrow ((\forall x)(\neg C) \Rightarrow (\forall x)(\neg
B))\)</span> <a href="#ex-2-27-a">2.27#a</a></li>
<li><span class="math inline">\((\forall x)(\neg C) \Rightarrow (\forall
x)(\neg B)\)</span> MP 上述两个</li>
<li><span class="math inline">\(((\forall x)(\neg C) \Rightarrow
(\forall x)(\neg B)) \Rightarrow (\neg (\forall x)(\neg B) \Rightarrow
\neg (\forall x)(\neg C))\)</span> <a
href="../chap-1-4/#lemma-1.11-e">Lemma 1.11#e</a></li>
<li><span class="math inline">\(\neg (\forall x)(\neg B) \Rightarrow
\neg (\forall x)(\neg C)\)</span> MP 上述两个</li>
</ol>
<p>上述证明了 <span class="math inline">\((\forall x)(B \Rightarrow C)
\vdash (\exists x)B \Rightarrow (\exists x)C\)</span>，唯一一步 Gen
其量词变量 <span class="math inline">\(x\)</span>
不是前提的自由变量，故可以用 DT</p>
</div></li>
<li><p><span id="ex-2-27-c"><code>c</code></span> <span
class="math inline">\(\vdash (\forall x)(B \wedge C) \Leftrightarrow
(\forall x)B \wedge (\forall x)C\)</span></p>
<div class="proof">
<p>TODO</p>
</div></li>
<li><p><span id="ex-2-27-d"><code>d</code></span> <span
class="math inline">\(\vdash (\forall y_1)...(\forall y_n)B \Rightarrow
B\)</span></p>
<div class="proof">
<ol type="1">
<li><span class="math inline">\((\forall y_1)...(\forall y_n)B\)</span>
Hyp</li>
<li><span class="math inline">\((\forall y_1)...(\forall y_n)B
\Rightarrow (\forall y_2)...(\forall y_n)B\)</span> A4</li>
<li><span class="math inline">\((\forall y_2)...(\forall y_n)B\)</span>
MP 上述两个</li>
<li>反复进行上面的操作直到剩下 <span
class="math inline">\(B\)</span></li>
</ol>
</div></li>
<li><p><span id="ex-2-27-e"><code>e</code></span> <span
class="math inline">\(\vdash \neg (\forall x)B \Rightarrow (\exists x)
\neg B\)</span></p>
<div class="proof">
<ol type="1">
<li><span class="math inline">\(\neg \neg B \Rightarrow B\)</span> <a
href="../chap-1-4/#lemma-1.11-a">Lemma 1.11#a</a></li>
<li><span class="math inline">\((\forall x)(\neg \neg B \Rightarrow
B)\)</span> Gen</li>
<li><span class="math inline">\((\forall x)(\neg \neg B \Rightarrow B)
\Rightarrow ((\forall x)(\neg \neg B) \Rightarrow (\forall x)B)\)</span>
<a href="#ex-2-27-a">2.27#a</a></li>
<li><span class="math inline">\((\forall x)(\neg \neg B) \Rightarrow
(\forall x)B\)</span> MP 上述两个</li>
<li><span class="math inline">\(((\forall x)(\neg \neg B) \Rightarrow
(\forall x)B) \Rightarrow (\neg(\forall x)B \Rightarrow \neg (\forall
x)(\neg \neg B))\)</span> <a href="../chap-1-4/#lemma-1.11-e">Lemma
1.11#e</a></li>
<li><span class="math inline">\(\neg(\forall x)B \Rightarrow \neg
(\forall x)(\neg \neg B)\)</span> MP 上述两个</li>
</ol>
</div></li>
</ul>
<h4 id="证明以下两个理论有相同的定理集合">2.28
证明以下两个理论有相同的定理集合</h4>
<blockquote>
<p>令 <span class="math inline">\(K\)</span> 是一个一阶理论，令 <span
class="math inline">\(K^{\#}\)</span> 是一个有如下公理的形式化理论：</p>
<ul>
<li><code>a</code> <span class="math inline">\((\forall y_1)...(\forall
y_n)B\)</span>，其中 <span class="math inline">\(B\)</span> 是 <span
class="math inline">\(K\)</span> 中的公理，<span
class="math inline">\(y_1, ..., y_n (n \ge 0)\)</span> 是任意变量</li>
<li><code>b</code> <span class="math inline">\((\forall y_1)...(\forall
y_n)(B \Rightarrow C) \Rightarrow ((\forall y_1)...(\forall y_n)B
\Rightarrow (\forall y_1)...(\forall y_n)C)\)</span>， 其中 <span
class="math inline">\(B\)</span> 和 <span
class="math inline">\(C\)</span> 是任意公式，<span
class="math inline">\(y_1, ..., y_n\)</span> 是任意变量</li>
</ul>
<p>且 MP 是 <span class="math inline">\(K^{\#}\)</span>
的唯一演绎规则</p>
<p>这个证明可以表明了添加额外的公理能把 Gen 替换掉</p>
</blockquote>
<div class="proof">
<p><em>（以下将 <span class="math inline">\((\forall y_1)...(\forall
y_n)\)</span> 缩写为 <span class="math inline">\((\forall
y_{1..n})\)</span> 以免括号太多眼花）</em></p>
<p>首先证明 <span class="math inline">\(K^{\#}\)</span> 的两个公理也是
<span class="math inline">\(K\)</span> 中的公理/定理</p>
<ul>
<li><p><code>a</code> 很简单，只要对 <span
class="math inline">\(B\)</span> 应用 <span
class="math inline">\(n\)</span> 次 Gen 就可以得出</p></li>
<li><p><code>b</code> 若 <span class="math inline">\(n =
0\)</span>，则退化为 <span class="math inline">\((B \Rightarrow C)
\Rightarrow (B \Rightarrow C)\)</span>，直接用 <a
href="../chap-1-4/#lemma-1.8">Lemma 1.8</a> 得出结果， 以下证明 <span
class="math inline">\(n &gt; 0\)</span> ：</p>
<ol type="1">
<li><span class="math inline">\((\forall y_{1..n})(B \Rightarrow C)
\Rightarrow ((\forall y_{1..n})B \Rightarrow (\forall
y_{1..n})C)\)</span> Hyp</li>
<li><span class="math inline">\((\forall x)((\forall y_{1..n})(B
\Rightarrow C) \Rightarrow ((\forall y_{1..n})B \Rightarrow (\forall
y_{1..n})C))\)</span> Gen</li>
<li><span class="math inline">\((\forall x)(\forall y_{1..n})(B
\Rightarrow C) \Rightarrow (\forall x)((\forall y_{1..n})B \Rightarrow
(\forall y_{1..n})C)\)</span> <a href="#ex-2-27-a">2.27#a</a> 和 2 MP
得出</li>
<li><span class="math inline">\((\forall x)((\forall y_{1..n})B
\Rightarrow (\forall y_{1..n})C) \Rightarrow ((\forall x)(\forall
y_{1..n})B \Rightarrow (\forall x)(\forall y_{1..n})C)\)</span> <a
href="#ex-2-27-a">2.27#a</a></li>
<li><span class="math inline">\((\forall x)(\forall y_{1..n})(B
\Rightarrow C) \Rightarrow ((\forall x)(\forall y_{1..n})B \Rightarrow
(\forall x)(\forall y_{1..n})C)\)</span> <a
href="../chap-1-4/#corollary-1.10">Corollary 1.10</a> 3 和 4 得出</li>
</ol>
<p>反复应用上述步骤，就能添加任意多的量词变量</p></li>
</ul>
<p>由于 <span class="math inline">\(K^{\#}\)</span> 只有
MP，从这两个公理出发产生的定理也必定是 <span
class="math inline">\(K\)</span> 中的定理（<span
class="math inline">\(K^{\#} \subseteq K\)</span>）</p>
<p>下面用归纳法证明若 <span class="math inline">\(\vdash_K
B\)</span>，则 <span class="math inline">\(\vdash_{K^{\#}} (\forall
y_{1..n})B\)</span>，令 <span class="math inline">\(D_1, ...,
D_m\)</span> 是 <span class="math inline">\(\vdash_K B\)</span>
的证明序列，</p>
<ul>
<li><span class="math inline">\(D_1\)</span> 必定是 <span
class="math inline">\(K\)</span> 中的公理，由公理 <code>a</code>
直接得出 <span class="math inline">\(\vdash_{K^{\#}} (\forall
y_{1..n})D_1\)</span></li>
<li>假设 <span class="math inline">\(i &lt; m\)</span>
时命题成立，现在考虑 <span class="math inline">\(\vdash_K D_m\)</span>
<ul>
<li>若 <span class="math inline">\(D_m\)</span> 是 <span
class="math inline">\(K\)</span> 中公理，由 <code>a</code> 得出 <span
class="math inline">\(\vdash_{K^{\#}} (\forall
y_{1..n})D_m\)</span></li>
<li>若 <span class="math inline">\(D_m\)</span> 是 <span
class="math inline">\(D_l \Rightarrow D_m\)</span> 和 <span
class="math inline">\(D_l\)</span> MP 而得，由归纳假设有 <span
class="math inline">\(\vdash_{K^{\#}} (\forall y_{1..n})(D_l \Rightarrow
D_m)\)</span> 以及 <span class="math inline">\(\vdash_{K^{\#}} (\forall
y_{1..n})(D_l)\)</span>，由 <code>b</code> MP 两次即可得到 <span
class="math inline">\(\vdash_{K^{\#}} (\forall
y_{1..n})D_m\)</span></li>
<li>若 <span class="math inline">\(D_m\)</span> 是 <span
class="math inline">\((\forall x)D_l\)</span>，由归纳假设有 <span
class="math inline">\(\vdash_{K^{\#}} (\forall y_{1..n}
x)D_l\)</span>，也就是 <span class="math inline">\(\vdash_{K^{\#}}
(\forall y_{1..n})D_m\)</span></li>
</ul></li>
</ul>
<p>当 <span class="math inline">\(n = 0\)</span> 时，<span
class="math inline">\(\vdash_{K^{\#}} (\forall y_{1..n})B\)</span> 即
<span class="math inline">\(\vdash_{K^{\#}} B\)</span>，故 <span
class="math inline">\(K\)</span> 的定理也必定是 <span
class="math inline">\(K^{\#}\)</span> 的定理（<span
class="math inline">\(K \subseteq K^{\#}\)</span>）</p>
</div>
<h4 id="证明-extension-of-propositions-2.42.7">2.29 证明 Extension of
Propositions 2.4–2.7</h4>
<p>上面已经证明了</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://math.stackexchange.com/q/4163851/975791"
class="uri">https://math.stackexchange.com/q/4163851/975791</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</article>
<!--main article end-->

</body>
</html>
