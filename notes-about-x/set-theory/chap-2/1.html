<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="HJW" />
  <meta name="dcterms.date" content="2025-02-11" />
  <title>2. Ordinal Numbers (1) Ordering</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <!-- latex css begin -->
  <link href="/assets/latex.css/style.min.css" rel="stylesheet" />
  <style>
  /* fixes for latex.css */
  .date {
    text-align: center;
  }

  div.sourceCode {
    background: var(--pre-bg-color);
    border-radius: 10px;
  }

  dl dd {
    text-align: left;
  }

  #footnotes {
    margin-top: 1em;
  }

  #footnotes hr:first-child {
    display: none;
  }
  </style>
  <!-- latex css end -->

  <!-- venobox begin -->
  <link rel="stylesheet" href="/assets/venobox/dist/venobox.min.css" />
  <script src="/assets/venobox/dist/venobox.min.js"></script>
  <script>
    window.addEventListener("load", (ev) => {
      document.querySelectorAll('img').forEach((img) => {
        const a = document.createElement("a")
        a.href = '#'
        a.setAttribute('data-href', img.src)
        a.classList.add('images')
        img.replaceWith(a)
        a.appendChild(img)
      })
      new VenoBox({
        selector: '.images',
        fitView: true,
      })
    })
  </script>
  <!-- venobox end -->

  <!-- layout begin -->
  <style>
  #sidebar {
    position: fixed;
    top: 0;
    left: 0;
    z-index: 999;
    max-width: 400px;
    width: 80%;
    height: 100%;
    padding: 2rem;
    background-color: #eee;
    box-shadow: 0 10px 20px -4px #000;
    overflow-x: hidden;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #ccc #eee;
    scrollbar-gutter: stable;
    pointer-events: none;
    opacity: 0;
    visibility: hidden;
    transform: translateX(-100%);
    transition: opacity 0.3s ease, visibility 0.2s ease, transform 0.3s ease;
  }
  #sidebar.show {
    pointer-events: all;
    opacity: 1;
    visibility: visible;
    transform: translateX(0);
  }
  #sidebar_toggler {
    position: fixed;
    top: 4vh;
    right: 3vw;
    z-index: 1000;
    width: 2.8rem;
    height: 2.4rem;
    padding: 0.5rem;
    border: solid #999 0.1rem;
    border-radius: 0.4rem;
    background-color: #fff;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    cursor: pointer;
    overflow: hidden;
  }

  #sidebar_toggler span {
    background-color: #999;
    width: 100%;
    height: 0.2rem;
    transition: all 0.3s ease;
    pointer-events: none;
  }
  nav span {
    display: inline-block;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    /*white-space: pre-wrap;*/
    width: 90%;
  }
  nav li:before {
    content: '';
  }
  nav span:before {
    content: "\25CF";
    margin-right: 8px;
  }
  nav .caret {
    cursor: pointer;
    user-select: none; /* Prevent text selection */
  }
  nav .caret::before {
    content: "\25B6";
    color: black;
    display: inline-block;
    margin-right: 6px;
  }
  nav .caret-down::before {
    transform: rotate(90deg);
  }
  nav .collapse {
    display: none;
  }
  </style>
  <script>
    window.addEventListener("load", (ev) => {
      /* setup sidebar */
      // https://www.cssscript.com/demo/responsive-sidebar-nav-hamburger/
      const sidebar = document.querySelector('#sidebar')
      const sidebarToggler = document.querySelector('#sidebar_toggler')

      sidebarToggler.addEventListener('click', () => {
        sidebar.classList.toggle('show')
      });

      const keywords = document.querySelector('meta[name="keywords"]')
      if (keywords && keywords.content.includes('showSidebar')) {
        sidebar.classList.add('show')
      }

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          sidebar.classList.remove('show')
        }
      })

      window.addEventListener('click', (e) => {
        if (!sidebar.contains(e.target) && !sidebarToggler.contains(e.target)) {
          sidebar.classList.remove('show')
        }
      });

      /* load urls */
      // https://www.w3schools.com/howto/howto_js_treeview.asp
      const currentPath = window.location.pathname
      const sideNavLinks = document.querySelector('#side_navlinks');
      function buildSideLink(li, node) {
        // span contains the text and link (if provided)
        const span = li.appendChild(document.createElement("span"))
        if (node.url) {
          const a = span.appendChild(document.createElement("a"))
          a.href = node.url
          a.textContent = node.text
        } else {
          span.textContent = node.text
        }
        span.setAttribute("title", node.text)

        // if has children, then add caret and append a nested <ul> for children
        if (node.children.length > 0) {
          span.classList.add("caret")
          const ul = li.appendChild(document.createElement("ul"))
          ul.classList.add("nested")
          // do not collapse current path
          if (!currentPath.startsWith(node.path)) {
            ul.classList.add("collapse")
          } else {
            span.classList.add("caret-down")
          }
          node.children.forEach((child) => {
            const l = ul.appendChild(document.createElement("li"))
            buildSideLink(l, child)
          })
        }
      }
      async function loadSideLinks() {
        const resp = await fetch("/urls.json")
        const data = await resp.json()
        // console.log(data)
        const root = sideNavLinks.appendChild(document.createElement("ul"))
        data.children.forEach((child) => {
          buildSideLink(root.appendChild(document.createElement("li")), child)
        })

        const toggler = root.getElementsByClassName("caret")
        for (let i=0; i<toggler.length; i++) {
          toggler[i].addEventListener("click", function () {
            this.parentElement.querySelector(".nested").classList.toggle("collapse")
            this.classList.toggle("caret-down")
            return false
          })
        }
      }
      loadSideLinks()
    })
  </script>
  <!-- layout end -->
  <script src="/assets/mathjax/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<!-- sidebar begin -->
<aside id="sidebar">
  <div class="sidebar_content sidebar_head">
    <h1>Content</h1>
  </div>
  <div class="sidebar_content sidebar_body">
    <nav id="side_navlinks" class="side_navlinks">
      <!--<ul>
        <li><a href="#">Home</a></li>
        <li><a href="#">About</a></li>
        <li><a href="#">Services</a></li>
        <li><a href="#">Portfolio</a></li>
        <li><a href="#">Contact</a></li>
      </ul>-->
    </nav>
  </div>
</aside>
<div id="sidebar_toggler">
  <span></span>
  <span></span>
  <span></span>
</div>
<!-- sidebar end -->

<!--main article begin-->
<article>
<header id="title-block-header">
<h1 class="title">2. Ordinal Numbers (1) Ordering</h1>
<p class="author">HJW</p>
<p class="date">2025-02-11</p>
</header>
<p><a href="./">Back</a></p>
<h2 id="各种-ordering">各种 Ordering</h2>
<p>整理了个图表示各种序（Order）的关系 <a href="#fn1"
class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>：</p>
<p><img src="ordering.excalidraw.png" /></p>
<hr />
<p><strong>transitive（传递性）<span class="math inline">\((\forall
a,b,c \in S) \; aRb \land bRc \rightarrow aRc\)</span></strong>
是这些序共有的性质，<mark>表明它们都是可以“组合”的</mark></p>
<p>传递性加上 <strong>irreflexive（反自反性）<span
class="math inline">\((\forall a \in S) \; \neg aRa\)</span></strong>
就直接是 <strong><em>Strict Partial Order（严格偏序）</em></strong></p>
<p><mark>严格偏序其实还蕴含 <strong>asymmetric（非对称性）<span
class="math inline">\((\forall a,b \in S) \; aRb \rightarrow \neg
bRa\)</span></strong>，只要 <span class="math inline">\(aRb\)</span>
成立则 <span class="math inline">\(bRa\)</span> 不成立， 因为假如 <span
class="math inline">\(aRb \land bRa\)</span> 都成立则由传递性可得 <span
class="math inline">\(aRa\)</span>，与反自反性矛盾</mark></p>
<p>传递性加上 <strong>reflexive（自反性）<span
class="math inline">\((\forall a \in S) \; aRa\)</span></strong>
这一分支：</p>
<ul>
<li><p>加上 <strong>symmetric（对称性）<span
class="math inline">\((\forall a,b \in S) \; aRb \rightarrow
bRa\)</span></strong> 就是熟悉的
<strong><em>Equivalence（等价关系）</em></strong></p></li>
<li><p>加上 <strong>anti-symmetric（反对称性）<span
class="math inline">\((\forall a,b \in S) \; aRb \land bRa \rightarrow a
= b\)</span></strong> 则是 <strong><em>Partial
Order（偏序）</em></strong></p>
<p><mark>其实反对称性也就是 <span class="math inline">\((\forall a,b \in
S) \; a \neq b \rightarrow aRb \rightarrow \neg bRa\)</span>，当 <span
class="math inline">\(a,b\)</span> 不同时满足非对称性</mark></p></li>
</ul>
<hr />
<p>（严格）偏序加上 <strong>connected（连接性）<span
class="math inline">\((\forall a,b \in S) \; a=b \lor aRb \lor
bRa\)</span></strong> 就得到 <strong><em>(Strict) Total/Linear
Order（（严格）全/线性序）</em></strong></p>
<p><mark>即任意两个不同的元素都是可以“比较”的了</mark></p>
<p><mark>前面的非对称性表示 <span class="math inline">\(aRb\)</span> 和
<span class="math inline">\(bRa\)</span> 不能同时存在，连接性则表示
<span class="math inline">\(aRb\)</span> 或 <span
class="math inline">\(bRa\)</span> 必有存在</mark></p>
<p><mark>每一个元素都可以把整个集合（除它自己外）划分成两部分：所有“小于”它的和所有“大于”它的，没有第三种可能了</mark></p>
<hr />
<p>若 <span class="math inline">\((P, \lt)\)</span> 是一个偏序集，<span
class="math inline">\(X\)</span> 非空且 <span class="math inline">\(X
\subset P\)</span> 且 <span class="math inline">\(a \in
P\)</span>，有如下定义：</p>
<ul>
<li><strong><em><span class="math inline">\(a\)</span> 是 <span
class="math inline">\(X\)</span> 中的 maximal element</em></strong> 就是
<mark><span class="math inline">\(a \in X\)</span> 且 <span
class="math inline">\(X\)</span> 中不存在比它更大的</mark>：<span
class="math inline">\(\neg (\exists x \in X) \; a &lt; x\)</span>
（偏序集里可能有多个）
<ul>
<li><em>minimal element</em> 类似</li>
</ul></li>
<li><strong><em><span class="math inline">\(a\)</span> 是 <span
class="math inline">\(X\)</span> 中的 greatest element</em></strong>
就是 <mark><span class="math inline">\(a \in X\)</span> 且 <span
class="math inline">\(X\)</span> 中的元素都小于等于它</mark>：<span
class="math inline">\((\forall x \in X) \; x \le a\)</span>
<ul>
<li><em>least element</em> 类似</li>
</ul></li>
<li><strong><em><span class="math inline">\(a\)</span> 是 <span
class="math inline">\(X\)</span> 的 upper bound</em></strong> 就是
<mark><span class="math inline">\(X\)</span>
中的元素都小于等于它</mark>：<span class="math inline">\((\forall x \in
X) \; x \le a\)</span> （<span class="math inline">\(a\)</span> 不必在
<span class="math inline">\(X\)</span> 中）
<ul>
<li><em>lower bound</em> 类似</li>
</ul></li>
<li><strong><em><span class="math inline">\(a\)</span> 是 <span
class="math inline">\(X\)</span> 的 supremum
(如果存在的话)</em></strong> 就是 <mark><span
class="math inline">\(a\)</span> 是 <span
class="math inline">\(X\)</span> 的 upper bound 集合中的 least
element</mark>，记作 <span class="math inline">\(sup \; X\)</span>
<ul>
<li><em>infimum</em> 类似，记作 <span class="math inline">\(inf \;
X\)</span></li>
</ul></li>
</ul>
<hr />
<p>假如 <span class="math inline">\((P, &lt;)\)</span> 和 <span
class="math inline">\((Q, &lt;&#39;)\)</span> 是两个偏序集，假如 <span
class="math inline">\(f: P \rightarrow Q\)</span> 满足 <span
class="math inline">\(x &lt; y \rightarrow f(x) &lt;&#39;
f(y)\)</span>， 则称之为 <strong><em>order preserving
function（保序函数）</em></strong>，如果 <span
class="math inline">\(P,Q\)</span> 都是线性序，则也称之为
<strong><em>increasing function（增函数）</em></strong>，例图：</p>
<p><img src="order-preserve.excalidraw.png" /></p>
<hr />
<p>假如 <span class="math inline">\(f: P \rightarrow Q\)</span>
是一个双射函数且 <span class="math inline">\(f\)</span> 和 <span
class="math inline">\(f^{-1}\)</span> 都是保序的，那么 <span
class="math inline">\(f\)</span> 是一个 <span
class="math inline">\(P\)</span> 和 <span
class="math inline">\(Q\)</span> 的
<strong><em>isomorphism（同构）</em></strong></p>
<p><span class="math inline">\(P\)</span> 和自己的同构称为
<strong><em>automorphism（自同构）</em></strong></p>
<p><mark>同构就是不单止元素是一一对应的，而且元素间的关系也保持同样的结构</mark></p>
<hr />
<p>（严格）线性序加上 <strong>well-founded（良基性）（所有非空子集都有
least element）</strong> 就得到 <strong><em>(Strict) Well
Order（（严格）良序）</em></strong></p>
<p><mark>不能<strong>只</strong>要求全局有 least
element，假如整数集加上一个额外的奇异数并定义这个奇异数小于所有整数，那么全局是有最小的，但其子集整数集却没有最小的</mark></p>
<h2 id="well-ordering-的性质">Well-Ordering 的性质</h2>
<p><strong>Lemma 2.4. 如果 <span class="math inline">\((W,
&lt;)\)</span> 是一个良序集 <a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a>，<span
class="math inline">\(f: W \rightarrow W\)</span> 是一个增函数，则 <span
class="math inline">\((\forall x \in W) \; f(x) \ge
x\)</span></strong></p>
<p><img src="lemma2.4.excalidraw.png" /></p>
<p><mark>直觉：如上图假如有一个 <span class="math inline">\(z\)</span>
使得 <span class="math inline">\(f(z) &lt; z\)</span>，那么所有 <span
class="math inline">\(f^n(z)\)</span>
构成的集合是没有最小元素的，这跟良基性矛盾</mark></p>
<div class="proof">
<p>假如集合 <span class="math inline">\(X = \{ x \in W: f(x) &lt; x
\}\)</span> 非空，由良基性存在一个最小的元素 <span
class="math inline">\(z\)</span> 且 <span class="math inline">\(f(z)
&lt; z\)</span>， 但因为 <span class="math inline">\(f\)</span>
是增函数故 <span class="math inline">\(f(f(z)) &lt; f(z)\)</span> 所以
<span class="math inline">\(f(z) \in W\)</span>，跟前面最小矛盾</p>
</div>
<hr />
<p><strong>Corollary 2.5. 良序集上的自同构只能是 identity
函数</strong></p>
<div class="proof">
<p>如果 <span class="math inline">\(f\)</span> 是自同构，那么 <span
class="math inline">\(f\)</span> 和 <span
class="math inline">\(f^{-1}\)</span> 都得是增函数，Lemma 2.4 可得 <span
class="math inline">\(f(x) \ge x\)</span> 以及 <span
class="math inline">\(x = f^{-1}(f(x)) \ge f(x)\)</span>，故 <span
class="math inline">\(x = f(x)\)</span></p>
</div>
<hr />
<p><strong>Corollary 2.6. 如果两个良序集 <span
class="math inline">\(W_1, W_2\)</span>
是同构的，那么只有唯一一个同构函数</strong></p>
<div class="proof">
<p>如果 <span class="math inline">\(f,g : W_1 \rightarrow W_2\)</span>
是两个同构函数，那么 <span class="math inline">\(g^{-1} \cdot f\)</span>
（其逆函数 <span class="math inline">\(f^{-1} \cdot g\)</span>）是一个
<span class="math inline">\(W_1\)</span> 上的自同构 （因为 <span
class="math inline">\(f,f^{-1},g,g^{-1}\)</span>
都是双射增函数，其组合也是双射增的），由 Corollary 2.5. 知 <span
class="math inline">\(g^{-1} \cdot f\)</span> 只能是 identity， 即 <span
class="math inline">\(f = g\)</span></p>
</div>
<hr />
<p>定义：若 <span class="math inline">\(W\)</span> 是良序集且 <span
class="math inline">\(u \in W\)</span>，那么 <span
class="math inline">\(W(u) = \{ x \in W: x &lt; u\}\)</span> 称为（由
<span class="math inline">\(u\)</span> 决定的）<span
class="math inline">\(W\)</span> 的一个 <strong><em>前段（initial
segment）</em></strong>，</p>
<p>另一种定义：<mark id="init-seg"><span
class="math inline">\(W\)</span> 的一个真子集 <span
class="math inline">\(X\)</span> 如果满足 <span class="math inline">\(x
\in X, y \in W\)</span> 且 <span class="math inline">\(y &lt; x\)</span>
则 <span class="math inline">\(y \in X\)</span>，则 <span
class="math inline">\(X\)</span> 是 <span
class="math inline">\(W\)</span> 的一个前段 <span
class="math inline">\(W(u)\)</span>，其中 <span
class="math inline">\(u\)</span> 是 <span class="math inline">\(W -
X\)</span> 中的最小元素</mark></p>
<p><mark>对于 <span class="math inline">\(W\)</span> 中的元素而言，<span
class="math inline">\(u\)</span> 大于且仅大于 <span
class="math inline">\(X\)</span> 中的那些元素</mark>，见下图</p>
<p><img src="initial-segment.excalidraw.png" /></p>
<hr />
<p><strong>Lemma 2.7. 良序集不可能同构于其任何前段</strong></p>
<div class="proof">
<p>假如有同构函数 <span class="math inline">\(f: W \rightarrow
W(u)\)</span>，所以它应该是一个增函数，但 <span
class="math inline">\(f(u) &lt; u\)</span>，和 Lemma 2.4. 矛盾</p>
</div>
<hr />
<p><strong>Theorem 2.8. 如果 <span
class="math inline">\(W_1,W_2\)</span>
是两个良序集，那么必定恰好有以下其中之一成立</strong></p>
<ul>
<li><strong><span class="math inline">\(W_1\)</span> 和 <span
class="math inline">\(W_2\)</span> 同构</strong></li>
<li><strong><span class="math inline">\(W_1\)</span> 和 <span
class="math inline">\(W_2\)</span> 的一个前段同构</strong></li>
<li><strong><span class="math inline">\(W_2\)</span> 和 <span
class="math inline">\(W_1\)</span> 的一个前段同构</strong></li>
</ul>
<p><mark>直觉：每次从 <span class="math inline">\(W_1,W_2\)</span>
中剩下的各取最小的那个对应起来（因为
well-founded，所以总能找到最小的），一直到至少有其中一边取完</mark></p>
<div class="proof">
<p>令</p>
<p><span class="math display">\[f = \{ (x, y) \in W_1 \times W_2 :
W_1(x) \; is \; isomorphic \; to \; W_2(y) \}\]</span></p>
<p>由 Lemma 2.7. 可知 <span class="math inline">\(f\)</span> 里的 pair
都是一一对应的，否则假如 <span class="math inline">\(y \neq z\)</span>
且 <span class="math inline">\((x, y), (x, z) \in f\)</span> 就会导致
<span class="math inline">\(W_2(y)\)</span> 与 <span
class="math inline">\(W_2(z)\)</span> 同构（<span
class="math inline">\(W_1\)</span> 对称同理）</p>
<p><strong>其次，假设 <span class="math inline">\((x, y) \in
f\)</span>，即 <span class="math inline">\(W_1(x)\)</span> 和 <span
class="math inline">\(W_2(y)\)</span> 有同构 <span
class="math inline">\(h\)</span>，则对于任意 <span
class="math inline">\((x&#39;, y&#39;) \in h\)</span>，<span
class="math inline">\(W_1(x&#39;)\)</span> 和 <span
class="math inline">\(W_2(y&#39;)\)</span> 也是同构的，即 <span
class="math inline">\((x&#39;, y&#39;) \in f\)</span></strong></p>
<blockquote>
<p>这是因为它们有同构 <span class="math inline">\(h&#39; = \{ (a,b) \in
h : a &lt; x&#39; \}\)</span>：</p>
<ul>
<li><span class="math inline">\(dom(h&#39;) = W_1(x&#39;)\)</span>
<ul>
<li>若 <span class="math inline">\(a \in dom(h&#39;)\)</span> 由 <span
class="math inline">\(h&#39;\)</span> 定义知 <span
class="math inline">\(a &lt; x&#39;\)</span></li>
<li>若 <span class="math inline">\(a &lt; x&#39;\)</span> 则 <span
class="math inline">\(a &lt; x\)</span> 所以 <span
class="math inline">\((a, h(a)) \in h\)</span> 则 <span
class="math inline">\(a \in dom(h&#39;)\)</span></li>
</ul></li>
<li><span class="math inline">\(rng(h&#39;) = W_2(y&#39;)\)</span>
<ul>
<li>若 <span class="math inline">\(b \in rng(h&#39;)\)</span> 由 <span
class="math inline">\(h&#39;\)</span> 定义知 <span
class="math inline">\(h^{-1}(b) &lt; x&#39;\)</span> 即 <span
class="math inline">\(b &lt; h(x&#39;) = y&#39;\)</span></li>
<li>若 <span class="math inline">\(b &lt; y&#39;\)</span> 则 <span
class="math inline">\(b &lt; y\)</span> 所以 <span
class="math inline">\((h^{-1}(b), b) \in h\)</span>，且 <span
class="math inline">\(h^{-1}(b) &lt; h^{-1}(y&#39;) =
x&#39;\)</span>，故 <span class="math inline">\(b \in
rng(h&#39;)\)</span></li>
</ul></li>
<li><span class="math inline">\(h&#39;\)</span> 是一对一的，否则 <span
class="math inline">\(h\)</span> 就不是一对一的</li>
<li><span class="math inline">\(h&#39;\)</span> 是保序的，否则 <span
class="math inline">\(h\)</span> 就不是保序的</li>
</ul>
</blockquote>
<p>由于 <span class="math inline">\(dom(h) = W_1(x)\)</span> 所以任意
<span class="math inline">\(x&#39; &lt; x\)</span> 都属于 <span
class="math inline">\(dom(f)\)</span>；同理由于 <span
class="math inline">\(rng(h) = W_2(y)\)</span> 所以任意 <span
class="math inline">\(y&#39; &lt; y\)</span> 上都属于 <span
class="math inline">\(rng(f)\)</span></p>
<p>对于任意 <span class="math inline">\(x&#39; &lt; x\)</span> 有 <span
class="math inline">\(f(x&#39;) = h(x&#39;) &lt; y = f(x)\)</span>，故
<span class="math inline">\(f\)</span> 是保序的</p>
<p>最后考虑</p>
<ul>
<li>假如 <span class="math inline">\(dom(f) = W_1\)</span> 且 <span
class="math inline">\(rng(f) = W_2\)</span>，那么 <span
class="math inline">\(W_1\)</span> 和 <span
class="math inline">\(W_2\)</span> 同构</li>
<li>如果 <span class="math inline">\(rng(f) \ne W_2\)</span>，令 <span
class="math inline">\(y_0\)</span> 是 <span class="math inline">\(W_2 -
rng(f)\)</span> 里最小的，由上面可知 <span
class="math inline">\(y_0\)</span> 必定大于 <span
class="math inline">\(rng(f)\)</span> 中任意元素； 此时 <span
class="math inline">\(dom(f)\)</span> 必定等于 <span
class="math inline">\(W_1\)</span>，否则同样可以令 <span
class="math inline">\(x_0\)</span> 是 <span class="math inline">\(W_1 -
dom(f)\)</span> 里最小的，同样 <span class="math inline">\(x_0\)</span>
必定大于 <span class="math inline">\(dom(f)\)</span> 中任意元素，
这样的话 <span class="math inline">\((x_0, y_0) \in
f\)</span>，矛盾</li>
<li>如果 <span class="math inline">\(dom(f) \ne W_1\)</span>，类似</li>
</ul>
<p>最后的最后，再次引用 Lemma 2.7. 这三种情况是互相排斥的</p>
</div>
<hr />
<p>如果 <span class="math inline">\(W_1\)</span> 和 <span
class="math inline">\(W_2\)</span> 同构，则称它们有相同的序类型（Order
Type）</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://oi-wiki.org/math/order-theory/#%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB"
class="uri">https://oi-wiki.org/math/order-theory/#%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>书里其实应该是严格良序<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</article>
<!--main article end-->

</body>
</html>
