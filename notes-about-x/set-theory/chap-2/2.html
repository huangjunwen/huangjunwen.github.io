<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2025-02-11" />
  <title>2. Ordinal Numbers (2) Ordinal Number</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link href="/assets/latex.css/style.min.css" rel="stylesheet" />
  <style>
  /* fixes for latex.css */
  .date {
    text-align: center;
  }

  div.sourceCode {
    background: var(--pre-bg-color);
    border-radius: 10px;
  }

  dl dd {
    text-align: left;
  }

  #footnotes {
    margin-top: 1em;
  }

  #footnotes hr:first-child {
    display: none;
  }
  </style>
  <script src="/assets/mathjax/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<style>
/* sidebar */
#sidebar {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 999;
  max-width: 400px;
  width: 80%;
  height: 100%;
  padding: 2rem;
  background-color: #eee;
  box-shadow: 0 10px 20px -4px #000;
  overflow-x: hidden;
  overflow-y: auto;
  pointer-events: none;
  opacity: 0;
  visibility: hidden;
  transform: translateX(-100%);
  transition: opacity 0.3s ease, visibility 0.2s ease, transform 0.3s ease;
}
#sidebar.show {
  pointer-events: all;
  opacity: 1;
  visibility: visible;
  transform: translateX(0);
}
#sidebar_toggler {
  position: fixed;
  top: 4vh;
  right: 3vw;
  z-index: 1000;
  width: 2.8rem;
  height: 2.4rem;
  padding: 0.5rem;
  border: solid #999 0.1rem;
  border-radius: 0.4rem;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  cursor: pointer;
  overflow: hidden;
}

#sidebar_toggler span {
  background-color: #999;
  width: 100%;
  height: 0.2rem;
  transition: all 0.3s ease;
  pointer-events: none;
}
nav span {
  display: inline-block;
  overflow: hidden;
  /* text-overflow: ellipsis; */
  /* white-space: nowrap; */
  white-space: pre-wrap;
  width: 90%;
}
nav li:before {
  content: '';
}
nav span:before {
  content: "\25CF";
  margin-right: 8px;
}
nav .caret {
  cursor: pointer;
  user-select: none; /* Prevent text selection */
}
nav .caret::before {
  content: "\25B6";
  color: black;
  display: inline-block;
  margin-right: 6px;
}
nav .caret-down::before {
  transform: rotate(90deg);
}
nav .collapse {
  display: none;
}
</style>
<aside id="sidebar">
  <div class="sidebar_content sidebar_head">
    <h1>Content</h1>
  </div>
  <div class="sidebar_content sidebar_body">
    <nav id="side_navlinks" class="side_navlinks">
      <!--<ul>
        <li><a href="#">Home</a></li>
        <li><a href="#">About</a></li>
        <li><a href="#">Services</a></li>
        <li><a href="#">Portfolio</a></li>
        <li><a href="#">Contact</a></li>
      </ul>-->
    </nav>
  </div>
</aside>
<div id="sidebar_toggler">
  <span></span>
  <span></span>
  <span></span>
</div>
<script>
/* setup sidebar */
// https://www.cssscript.com/demo/responsive-sidebar-nav-hamburger/
const sidebar = document.querySelector('#sidebar')
const sidebarToggler = document.querySelector('#sidebar_toggler')

sidebarToggler.addEventListener('click', () => {
  sidebar.classList.toggle('show')
});

const keywords = document.querySelector('meta[name="keywords"]')
if (keywords && keywords.content.includes('showSidebar')) {
  sidebar.classList.add('show')
}

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    sidebar.classList.remove('show')
  }
})

window.addEventListener('click', (e) => {
  if (!sidebar.contains(e.target) && !sidebarToggler.contains(e.target)) {
    sidebar.classList.remove('show')
  }
});

/* load urls */
// https://www.w3schools.com/howto/howto_js_treeview.asp
const currentPath = window.location.pathname
const sideNavLinks = document.querySelector('#side_navlinks');
function buildSideLink(li, node) {
  // span contains the text and link (if provided)
  const span = li.appendChild(document.createElement("span"))
  if (node.url) {
    const a = span.appendChild(document.createElement("a"))
    a.href = node.url
    a.textContent = node.text
  } else {
    span.textContent = node.text
  }
  span.setAttribute("title", node.text)

  // if has children, then add caret and append a nested <ul> for children
  if (node.children.length > 0) {
    span.classList.add("caret")
    const ul = li.appendChild(document.createElement("ul"))
    ul.classList.add("nested")
    // do not collapse current path
    if (!currentPath.startsWith(node.path)) {
      ul.classList.add("collapse")
    } else {
      span.classList.add("caret-down")
    }
    node.children.forEach((child) => {
      const l = ul.appendChild(document.createElement("li"))
      buildSideLink(l, child)
    })
  }
}
async function loadSideLinks() {
  const resp = await fetch("/urls.json")
  const data = await resp.json()
  // console.log(data)
  const root = sideNavLinks.appendChild(document.createElement("ul"))
  data.children.forEach((child) => {
    buildSideLink(root.appendChild(document.createElement("li")), child)
  })

  const toggler = root.getElementsByClassName("caret")
  for (let i=0; i<toggler.length; i++) {
    toggler[i].addEventListener("click", function () {
      this.parentElement.querySelector(".nested").classList.toggle("collapse")
      this.classList.toggle("caret-down")
      return false
    })
  }
}
loadSideLinks()
</script>
<header id="title-block-header">
<h1 class="title">2. Ordinal Numbers (2) Ordinal Number</h1>
<p class="date">2025-02-11</p>
</header>
<p><a href="./">Back</a></p>
<h2 id="ordinal-number">Ordinal Number</h2>
<p>很自然的一个想法是定义一类（<em>Ord</em>）良序集作为“度量”（序数），使得任意良序集都可以在其中找到一个与之同构的作为“代表”：</p>
<p><img src="ordinal.excalidraw.png" /></p>
<p>首先序的 binary relationship 多种多样，集合论里最现成的是 <span
class="math inline">\(\in\)</span></p>
<p>其次我们希望“更大”的序数是小一点的序数的拓展，这样做保证两个不同序数总有首段子集关系（<span
class="math inline">\(A\)</span> 是 <span
class="math inline">\(B\)</span> 的首段子集或反过来），
于是它们是不可能同构的（Lemma
2.7），<mark>于是一个良序集最多只能和（唯一）一个序数同构</mark></p>
<p>怎么拓展呢？大序数里新增的元素应当大于（包含）已有首段里的所有元素，<mark>不多不少刚好就是之前的某个序数本身</mark>
（例如，<span class="math inline">\(n+1\)</span> 中的新增元素 <span
class="math inline">\(E_{n+1} = n\)</span>；对于极限序数 <span
class="math inline">\(\omega\)</span>，它尾段里新增的无数个元素也是之前的某个序数）</p>
<p><mark>也就是说序数的元素是更小的序数，其本身也会成为更大的序数的元素</mark></p>
<p>所以一个序数不单止其包含的元素需要满足良序集（<span
class="math inline">\(\in\)</span>
之下）的条件，加上其本身也需要满足，因为它将是更大序数的元素</p>
<p>例如传递性：</p>
<hr />
<p><strong>Definition 2.9. A set <span class="math inline">\(T\)</span>
is transitive if every element of <span class="math inline">\(T\)</span>
is a subset of <span class="math inline">\(T\)</span></strong></p>
<p>也就是说如果 <span class="math inline">\(a \in b \in T\)</span> 则
<span class="math inline">\(a \in T\)</span></p>
<p><mark>这会导致 <span class="math inline">\(T\)</span>
的所有子孙元素都因传递性而成为 <span class="math inline">\(T\)</span>
的“直接”元素</mark>：</p>
<p><img src="transitive.excalidraw.png" /></p>
<p>所以最终序数的定义是：</p>
<p><strong>Definition 2.10. A set is an ordinal number (an ordinal) if
it is transitive and well-ordered by <span
class="math inline">\(\in\)</span></strong></p>
<p>下面开始也使用 <span class="math inline">\(\alpha &lt; \beta\)</span>
表示 <span class="math inline">\(\alpha \in \beta\)</span></p>
<hr />
<p><strong>Lemma 2.11.</strong></p>
<ol type="1">
<li><p><span class="math inline">\(0 = \emptyset\)</span>
是一个序数</p></li>
<li><p>如果 <span class="math inline">\(\alpha\)</span> 是一个序数，而
<span class="math inline">\(\beta \in \alpha\)</span>，则 <span
class="math inline">\(\beta\)</span> 也是一个序数</p>
<div class="proof">
<p>由于 <span class="math inline">\(\beta \in \alpha\)</span> （因 <span
class="math inline">\(\alpha\)</span> 传递性）所以 <span
class="math inline">\(\beta \subset
\alpha\)</span>，作为良序集的子集，<span
class="math inline">\(\beta\)</span>
也是一个良序集（其元素满足传递、反自反、连接、良基）</p>
<p>若 <span class="math inline">\(\delta \in \gamma \in \beta \in
\alpha\)</span>（因 <span class="math inline">\(\alpha\)</span>
传递性）故 <span class="math inline">\(\delta \in \alpha\)</span>，
于是（因 <span class="math inline">\(\alpha\)</span> 连接性）要么 <span
class="math inline">\(\delta \in \beta\)</span> 要么 <span
class="math inline">\(\beta \in
\delta\)</span>，但后者是不可能的否则违反反自反性，故 <span
class="math inline">\(\delta \in \beta\)</span>， 于是 <span
class="math inline">\(\beta\)</span> 也满足传递性</p>
</div></li>
<li><p>如果 <span class="math inline">\(\alpha\)</span> 和 <span
class="math inline">\(\beta\)</span> 是两个不同的序数且 <span
class="math inline">\(\beta \subset \alpha\)</span>，则 <span
class="math inline">\(\beta \in \alpha\)</span></p>
<div class="proof">
<p><span class="math inline">\(\beta\)</span> 是 <span
class="math inline">\(\alpha\)</span> 的一个<a
href="1.html#init-seg">前段</a>，因为：</p>
<ul>
<li>若 <span class="math inline">\(x \in \beta\)</span> 以及 <span
class="math inline">\(y \in \alpha\)</span> 且 <span
class="math inline">\(y &lt; x\)</span> （<span class="math inline">\(y
\in x\)</span>），由于 <span class="math inline">\(\beta\)</span>
的传递性 <span class="math inline">\(y \in \beta\)</span></li>
<li><span class="math inline">\(\beta\)</span> 是 <span
class="math inline">\(\alpha\)</span> 的真子集</li>
</ul>
<p>令 <span class="math inline">\(\gamma\)</span> 是 <span
class="math inline">\(\alpha - \beta\)</span> 中最小的那个元素，
<mark>于是对于 <span class="math inline">\(\alpha\)</span> 中的元素而言
<span class="math inline">\(\gamma\)</span>
包含（大于）且仅包含（大于）<span class="math inline">\(\beta\)</span>
中的那些元素</mark>， 注意这里是 <em>对于 <span
class="math inline">\(\alpha\)</span> 中的元素而言</em>，<mark>但 <span
class="math inline">\(\gamma\)</span> 不可能包含 <span
class="math inline">\(\alpha\)</span> 的元素之外的元素（<span
class="math inline">\(\alpha\)</span> 的传递性）</mark>，故 <span
class="math inline">\(\gamma = \beta\)</span></p>
</div></li>
<li><p>如果 <span class="math inline">\(\alpha\)</span> 和 <span
class="math inline">\(\beta\)</span> 是两个序数，则要么 <span
class="math inline">\(\alpha \subset \beta\)</span> 要么 <span
class="math inline">\(\beta \subset \alpha\)</span></p>
<div class="proof">
<p>令 <span class="math inline">\(\gamma = \alpha \cap
\beta\)</span>，则 <span class="math inline">\(\gamma\)</span>
也是一个序数：</p>
<ul>
<li>良序集的子集也是良序集</li>
<li>若 <span class="math inline">\(x \in \gamma\)</span> 则 <span
class="math inline">\(x \in \alpha\)</span> 和 <span
class="math inline">\(x \in \beta\)</span>，于是 <span
class="math inline">\(x \subset \alpha\)</span> 和 <span
class="math inline">\(x \subset \beta\)</span>，于是 <span
class="math inline">\(x \subset \gamma\)</span>， 所以 <span
class="math inline">\(\gamma\)</span> 也满足传递性</li>
</ul>
<p>如果 <span class="math inline">\(\gamma \neq \alpha\)</span> 且 <span
class="math inline">\(\gamma \neq \beta\)</span>，则由上面 3 则有 <span
class="math inline">\(\gamma \in \alpha\)</span> 和 <span
class="math inline">\(\gamma \in \beta\)</span> 于是 <span
class="math inline">\(\gamma \in \gamma\)</span>，矛盾</p>
<p>故 <span class="math inline">\(\gamma = \alpha\)</span> 和 <span
class="math inline">\(\gamma = \beta\)</span> 至少有一个要成立，也就是
<span class="math inline">\(\alpha \subset \beta\)</span> 或 <span
class="math inline">\(\beta \subset \alpha\)</span> 了</p>
<p><mark>额外的如果 <span class="math inline">\(\alpha \neq
\beta\)</span> 那么根据 3，就有 <span class="math inline">\(\alpha \in
\beta\)</span> 或 <span class="math inline">\(\beta \in \alpha\)</span>
了</mark></p>
</div></li>
</ol>
<hr />
<ul>
<li><p>(2.1) 所有序数组成的类 <em>Ord</em> 是以 <span
class="math inline">\(&lt;(\in)\)</span>
为线性序的；因为两两不同的序数都有包含关系</p></li>
<li><p>(2.2) 每一个序数 <span class="math inline">\(\alpha\)</span> 都有
<span class="math inline">\(\alpha = \{\beta: \beta &lt;
\alpha\}\)</span>；因为首先 <span class="math inline">\(\alpha\)</span>
的元素都是比 <span class="math inline">\(\alpha\)</span> 小的序数，
其次比 <span class="math inline">\(\alpha\)</span> 小的序数都是 <span
class="math inline">\(\alpha\)</span>
的元素（因为两两不同序数都有包含关系）</p></li>
<li><p>(2.3) 若 <span class="math inline">\(C\)</span>
是非空的序数类（不一定是集合），则 <span class="math inline">\(\bigcap
C\)</span> 也是一个序数，且 <span class="math inline">\(\bigcap C \in
C\)</span> 以及 <span class="math inline">\(\bigcap C = inf \;
C\)</span></p>
<div class="proof">
<p>首先 <span class="math inline">\(\bigcap C\)</span>
是一个集合（因为至少存在一个集合 <span class="math inline">\(O \in
C\)</span>，而 <span class="math inline">\(\bigcap C \subset
O\)</span>，子集公理）</p>
<p>然后类似上面 4 般证明 <span class="math inline">\(\bigcap C\)</span>
也是序数</p>
<ul>
<li>良序集的子集也是良序集</li>
<li>若 <span class="math inline">\(x \in \bigcap C\)</span> 于是对所有
<span class="math inline">\(O \in C\)</span> 都有 <span
class="math inline">\(x \in O\)</span>，由于 <span
class="math inline">\(O\)</span> 都是序数所以 <span
class="math inline">\(x \subset O\)</span> 于是 <span
class="math inline">\(x \subset \bigcap C\)</span>，也就满足传递性</li>
</ul>
<p>现在假设 <span class="math inline">\(\bigcap C \notin
C\)</span>，也就是对于所有 <span class="math inline">\(C\)</span> 中元素
<span class="math inline">\(\bigcap C\)</span> 都是它们的
<em>真子集</em>，由上面 3 可得 <span class="math inline">\(\bigcap
C\)</span> 也是它们的 <em>元素</em>， 这就会导致 <span
class="math inline">\(\bigcap C \in \bigcap C\)</span> 而矛盾</p>
<p><mark>所以 <span class="math inline">\(\bigcap C\)</span> 能直接获得
<span class="math inline">\(C\)</span> 里最小的那个序数</mark></p>
</div></li>
<li><p>(2.4) 若 <span class="math inline">\(X\)</span>
是非空的序数集合，则 <span class="math inline">\(\bigcup X\)</span>
也是一个序数，且 <span class="math inline">\(\bigcup X = sup \;
X\)</span></p>
<div class="proof">
<p>首先由于序数的元素都是序数，所以 <span class="math inline">\(\bigcup
X\)</span> 的元素都是序数，于是它是线性序的（2.1）</p>
<p><mark>对于任意 <span class="math inline">\(\bigcup X\)</span> 的子集
<span class="math inline">\(C\)</span>，由（2.3）可知存在<span
class="math inline">\(\bigcap C\)</span> 这个最小元素，所以 <span
class="math inline">\(\bigcup X\)</span> 是良基的</mark></p>
<p>最后对于任意 <span class="math inline">\(x \in \bigcup
X\)</span>，存在某个序数 <span class="math inline">\(O \in X\)</span>
使得 <span class="math inline">\(x \in O\)</span>，于是 <span
class="math inline">\(x \subset O\)</span> 于是 <span
class="math inline">\(x \subset \bigcup X\)</span>，所以 <span
class="math inline">\(\bigcup X\)</span> 满足传递性</p>
</div></li>
<li><p>(2.5) 对于任意序数 <span
class="math inline">\(\alpha\)</span>，<span
class="math inline">\(\alpha \cup \{ \alpha \}\)</span> 也是序数，且
<span class="math inline">\(\alpha \cup \{ \alpha \} = inf \; \{ \beta:
\beta &gt; \alpha \}\)</span>， 定义 <span class="math inline">\(\alpha
+ 1 = \alpha \cup \{ \alpha \}\)</span></p></li>
</ul>
<link rel="stylesheet" href="/assets/venobox/dist/venobox.min.css" />
<script src="/assets/venobox/dist/venobox.min.js"></script>
<script>
  document.querySelectorAll('img').forEach((img) => {
    const a = document.createElement("a")
    a.href = '#'
    a.setAttribute('data-href', img.src)
    a.classList.add('images')
    img.replaceWith(a)
    a.appendChild(img)
  })
  new VenoBox({
    selector: '.images',
    fitView: true,
  });
</script>
</body>
</html>
